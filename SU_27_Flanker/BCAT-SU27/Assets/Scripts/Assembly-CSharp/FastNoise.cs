using System;
using System.Runtime.CompilerServices;

public class FastNoise
{
	public enum NoiseType
	{
		Value,
		ValueFractal,
		Perlin,
		PerlinFractal,
		Simplex,
		SimplexFractal,
		Cellular,
		WhiteNoise,
		Cubic,
		CubicFractal
	}

	public enum Interp
	{
		Linear,
		Hermite,
		Quintic
	}

	public enum FractalType
	{
		FBM,
		Billow,
		RigidMulti
	}

	public enum CellularDistanceFunction
	{
		Euclidean,
		Manhattan,
		Natural
	}

	public enum CellularReturnType
	{
		CellValue,
		NoiseLookup,
		Distance,
		Distance2,
		Distance2Add,
		Distance2Sub,
		Distance2Mul,
		Distance2Div
	}

	private struct Float2
	{
		public readonly double x;

		public readonly double y;

		public Float2(double x, double y)
		{
			this.x = x;
			this.y = y;
		}
	}

	private struct Float3
	{
		public readonly double x;

		public readonly double y;

		public readonly double z;

		public Float3(double x, double y, double z)
		{
			this.x = x;
			this.y = y;
			this.z = z;
		}
	}

	private const short FN_INLINE = 256;

	private const int FN_CELLULAR_INDEX_MAX = 3;

	private int m_seed = 1337;

	private double m_frequency = 0.01;

	private Interp m_interp = Interp.Quintic;

	private NoiseType m_noiseType = NoiseType.Simplex;

	private int m_octaves = 3;

	private double m_lacunarity = 2.0;

	private double m_gain = 0.5;

	private FractalType m_fractalType;

	private double m_fractalBounding;

	private CellularDistanceFunction m_cellularDistanceFunction;

	private CellularReturnType m_cellularReturnType;

	private FastNoise m_cellularNoiseLookup;

	private int m_cellularDistanceIndex0;

	private int m_cellularDistanceIndex1 = 1;

	private float m_cellularJitter = 0.45f;

	private double m_gradientPerturbAmp = 1.0;

	private static readonly Float2[] GRAD_2D = new Float2[8]
	{
		new Float2(-1.0, -1.0),
		new Float2(1.0, -1.0),
		new Float2(-1.0, 1.0),
		new Float2(1.0, 1.0),
		new Float2(0.0, -1.0),
		new Float2(-1.0, 0.0),
		new Float2(0.0, 1.0),
		new Float2(1.0, 0.0)
	};

	private static readonly Float3[] GRAD_3D = new Float3[16]
	{
		new Float3(1.0, 1.0, 0.0),
		new Float3(-1.0, 1.0, 0.0),
		new Float3(1.0, -1.0, 0.0),
		new Float3(-1.0, -1.0, 0.0),
		new Float3(1.0, 0.0, 1.0),
		new Float3(-1.0, 0.0, 1.0),
		new Float3(1.0, 0.0, -1.0),
		new Float3(-1.0, 0.0, -1.0),
		new Float3(0.0, 1.0, 1.0),
		new Float3(0.0, -1.0, 1.0),
		new Float3(0.0, 1.0, -1.0),
		new Float3(0.0, -1.0, -1.0),
		new Float3(1.0, 1.0, 0.0),
		new Float3(0.0, -1.0, 1.0),
		new Float3(-1.0, 1.0, 0.0),
		new Float3(0.0, -1.0, -1.0)
	};

	private static readonly Float2[] CELL_2D = new Float2[256]
	{
		new Float2(-0.2700222134590149, -0.9628540873527527),
		new Float2(0.38630926609039307, -0.9223693013191223),
		new Float2(0.04444859176874161, -0.9990116953849792),
		new Float2(-0.5992523431777954, -0.8005602359771729),
		new Float2(-0.7819280028343201, 0.6233687400817871),
		new Float2(0.9464672207832336, 0.3227999210357666),
		new Float2(-0.651414692401886, -0.7587218880653381),
		new Float2(0.9378472566604614, 0.3470483720302582),
		new Float2(-0.8497875928878784, -0.5271252393722534),
		new Float2(-0.8790425658226013, 0.47674325108528137),
		new Float2(-0.8923003077507019, -0.4514423608779907),
		new Float2(-0.37984442710876465, -0.9250503778457642),
		new Float2(-0.9951651096343994, 0.09821637719869614),
		new Float2(0.7724397778511047, -0.6350880265235901),
		new Float2(0.7573283314704895, -0.6530343294143677),
		new Float2(-0.9928004741668701, -0.1197800561785698),
		new Float2(-0.05326656997203827, 0.9985803365707397),
		new Float2(0.9754253625869751, -0.22033007442951202),
		new Float2(-0.7665018439292908, 0.6422421336174011),
		new Float2(0.9916366934776306, 0.12906061112880707),
		new Float2(-0.994696855545044, 0.10285037755966187),
		new Float2(-0.5379205346107483, -0.8429955244064331),
		new Float2(0.5022815465927124, -0.8647041320800781),
		new Float2(0.45598214864730835, -0.889988899230957),
		new Float2(-0.8659130930900574, -0.5001944303512573),
		new Float2(0.0879458412528038, -0.9961252808570862),
		new Float2(-0.5051684975624084, 0.8630207180976868),
		new Float2(0.7753185033798218, -0.6315703988075256),
		new Float2(-0.6921944618225098, 0.7217110395431519),
		new Float2(-0.5191659331321716, -0.854673445224762),
		new Float2(0.8978623151779175, -0.4402764141559601),
		new Float2(-0.17067740857601166, 0.9853269457817078),
		new Float2(-0.9353430271148682, -0.3537420630455017),
		new Float2(-0.9992404580116272, 0.03896746784448624),
		new Float2(-0.28820639848709106, -0.9575682878494263),
		new Float2(-0.9663811326026917, 0.25711381435394287),
		new Float2(-0.8759714365005493, -0.4823630154132843),
		new Float2(-0.8303123116493225, -0.5572983622550964),
		new Float2(0.05110133811831474, -0.9986934661865234),
		new Float2(-0.855837345123291, -0.5172450542449951),
		new Float2(0.09887025505304337, 0.9951003193855286),
		new Float2(0.9189016222953796, 0.39448678493499756),
		new Float2(-0.24393758177757263, -0.9697909355163574),
		new Float2(-0.812140941619873, -0.5834612846374512),
		new Float2(-0.9910431504249573, 0.13354213535785675),
		new Float2(0.8492423892021179, -0.5280031561851501),
		new Float2(-0.9717838764190674, -0.23587295413017273),
		new Float2(0.9949457049369812, 0.1004142090678215),
		new Float2(0.6241065263748169, -0.7813392281532288),
		new Float2(0.6629102826118469, 0.7486988306045532),
		new Float2(-0.7197418212890625, 0.6942418217658997),
		new Float2(-0.8143370747566223, -0.5803922414779663),
		new Float2(0.10452105104923248, -0.9945226907730103),
		new Float2(-0.10659261047840118, -0.9943027496337891),
		new Float2(0.44579967856407166, -0.8951327800750732),
		new Float2(0.10554740577936172, 0.9944142699241638),
		new Float2(-0.9927902817726135, 0.11986444890499115),
		new Float2(-0.8334366679191589, 0.5526150465011597),
		new Float2(0.9115561842918396, -0.41117560863494873),
		new Float2(0.8285545110702515, -0.5599084496498108),
		new Float2(0.7217097878456116, -0.6921957731246948),
		new Float2(0.4940492808818817, -0.8694338798522949),
		new Float2(-0.3652321398258209, -0.9309164881706238),
		new Float2(-0.9696606993675232, 0.24445484578609467),
		new Float2(0.08925509452819824, -0.9960088133811951),
		new Float2(0.5354071259498596, -0.8445941209793091),
		new Float2(-0.10535761713981628, 0.9944344162940979),
		new Float2(-0.9890284538269043, 0.14772510528564453),
		new Float2(0.004856104962527752, 0.9999881982803345),
		new Float2(0.9885598421096802, 0.15082913637161255),
		new Float2(0.9286129474639893, -0.37104982137680054),
		new Float2(-0.5832393765449524, -0.8123003244400024),
		new Float2(0.30152076482772827, 0.953459620475769),
		new Float2(-0.9575110673904419, 0.28839656710624695),
		new Float2(0.9715802073478699, -0.2367105484008789),
		new Float2(0.22998179495334625, 0.97319495677948),
		new Float2(0.9557638168334961, -0.2941352128982544),
		new Float2(0.7409561276435852, 0.6715534329414368),
		new Float2(-0.9971513748168945, -0.07542631030082703),
		new Float2(0.6905710697174072, -0.7232645153999329),
		new Float2(-0.29071369767189026, -0.9568101167678833),
		new Float2(0.5912777781486511, -0.8064679503440857),
		new Float2(-0.945459246635437, -0.3257404863834381),
		new Float2(0.6664455533027649, 0.7455536723136902),
		new Float2(0.6236134767532349, 0.7817328572273254),
		new Float2(0.9126994013786316, -0.40863165259361267),
		new Float2(-0.819176197052002, 0.5735419392585754),
		new Float2(-0.8812745809555054, -0.4726046025753021),
		new Float2(0.995331346988678, 0.09651672840118408),
		new Float2(0.9855650663375854, -0.1692969650030136),
		new Float2(-0.8495981097221375, 0.5274306535720825),
		new Float2(0.6174854040145874, -0.786582350730896),
		new Float2(0.8508156538009644, 0.5254642963409424),
		new Float2(0.9985032677650452, -0.054692499339580536),
		new Float2(0.19713716208934784, -0.9803759455680847),
		new Float2(0.6607855558395386, -0.7505747079849243),
		new Float2(-0.030974941328167915, 0.9995201826095581),
		new Float2(-0.6731660962104797, 0.73949134349823),
		new Float2(-0.7195018529891968, -0.6944905519485474),
		new Float2(0.9727511405944824, 0.23185159265995026),
		new Float2(0.9997059106826782, -0.024250689893960953),
		new Float2(0.44217875599861145, -0.8969269394874573),
		new Float2(0.9981350898742676, -0.061043672263622284),
		new Float2(-0.917366087436676, -0.39804455637931824),
		new Float2(-0.8150056600570679, -0.5794529914855957),
		new Float2(-0.8789331316947937, 0.47694501280784607),
		new Float2(0.015860583633184433, 0.9998742341995239),
		new Float2(-0.8095464706420898, 0.5870558023452759),
		new Float2(-0.9165899157524109, -0.3998286724090576),
		new Float2(-0.8023542761802673, 0.5968480706214905),
		new Float2(-0.5176737904548645, 0.8555780649185181),
		new Float2(-0.8154407143592834, -0.5788405537605286),
		new Float2(0.4022010266780853, -0.9155513644218445),
		new Float2(-0.9052556753158569, -0.4248672127723694),
		new Float2(0.7317445874214172, 0.6815789937973022),
		new Float2(-0.5647632479667664, -0.8252530097961426),
		new Float2(-0.8403276205062866, -0.5420788526535034),
		new Float2(-0.9314281344413757, 0.3639252483844757),
		new Float2(0.5238198637962341, 0.8518290519714355),
		new Float2(0.7432804107666016, -0.6689800024032593),
		new Float2(-0.9853715896606445, -0.17041973769664764),
		new Float2(0.46014687418937683, 0.8878428339958191),
		new Float2(0.8258553743362427, 0.5638819336891174),
		new Float2(0.6182366013526917, 0.7859920263290405),
		new Float2(0.8331502676010132, -0.5530466437339783),
		new Float2(0.15003074705600739, 0.9886813163757324),
		new Float2(-0.6623303890228271, -0.7492119073867798),
		new Float2(-0.6685986518859863, 0.7436234354972839),
		new Float2(0.7025606036186218, 0.7116239070892334),
		new Float2(-0.5419389605522156, -0.8404178619384766),
		new Float2(-0.3388616442680359, 0.9408361911773682),
		new Float2(0.8331530094146729, 0.5530425310134888),
		new Float2(-0.29897207021713257, -0.954261839389801),
		new Float2(0.2638522982597351, 0.9645630717277527),
		new Float2(0.12410873919725418, -0.9922686219215393),
		new Float2(-0.7282649278640747, -0.6852957010269165),
		new Float2(0.6962500214576721, 0.7177993655204773),
		new Float2(-0.9183535575866699, 0.39576101303100586),
		new Float2(-0.6326102018356323, -0.774470329284668),
		new Float2(-0.9331892132759094, -0.35938552021980286),
		new Float2(-0.11537793278694153, -0.9933216571807861),
		new Float2(0.951497495174408, -0.30765655636787415),
		new Float2(-0.08987977355718613, -0.9959526062011719),
		new Float2(0.6678497195243835, 0.7442961931228638),
		new Float2(0.795240044593811, -0.6062946915626526),
		new Float2(-0.6462007164955139, -0.7631675004959106),
		new Float2(-0.27335986495018005, 0.9619118571281433),
		new Float2(0.9669589996337891, -0.25493183732032776),
		new Float2(-0.9792894721031189, 0.20246519148349762),
		new Float2(-0.5369502902030945, -0.843613862991333),
		new Float2(-0.2700364589691162, -0.9628500938415527),
		new Float2(-0.6400277018547058, 0.7683518528938293),
		new Float2(-0.785453736782074, -0.6189203858375549),
		new Float2(0.06005905568599701, -0.9981948137283325),
		new Float2(-0.024557704105973244, 0.9996984004974365),
		new Float2(-0.6598362326622009, 0.7514094710350037),
		new Float2(-0.6253894567489624, -0.7803127765655518),
		new Float2(-0.6210408806800842, -0.783778190612793),
		new Float2(0.8348888754844666, 0.5504185557365417),
		new Float2(-0.15922752022743225, 0.9872419238090515),
		new Float2(0.8367622494697571, 0.5475663542747498),
		new Float2(-0.8675754070281982, -0.497305691242218),
		new Float2(-0.20226626098155975, -0.9793305397033691),
		new Float2(0.9399189949035645, 0.34139755368232727),
		new Float2(0.9877404570579529, -0.1561049073934555),
		new Float2(-0.9034455418586731, 0.42870283126831055),
		new Float2(0.12698042392730713, -0.9919052124023438),
		new Float2(-0.38196009397506714, 0.9241788387298584),
		new Float2(0.9754626154899597, 0.22016525268554688),
		new Float2(-0.3204015791416168, -0.9472818374633789),
		new Float2(-0.987476110458374, 0.15776874125003815),
		new Float2(0.025353483855724335, -0.9996785521507263),
		new Float2(0.48351308703422546, -0.8753371238708496),
		new Float2(-0.2850799858570099, -0.9585037231445312),
		new Float2(-0.068055160343647, -0.9976815581321716),
		new Float2(-0.7885243892669678, -0.6150034666061401),
		new Float2(0.31853920221328735, -0.9479097127914429),
		new Float2(0.8880043029785156, 0.45983514189720154),
		new Float2(0.6476921439170837, -0.7619021534919739),
		new Float2(0.9820241332054138, 0.18875542283058167),
		new Float2(0.9357275366783142, -0.35272371768951416),
		new Float2(-0.8894895315170288, 0.45695552229881287),
		new Float2(0.7922791242599487, 0.6101588010787964),
		new Float2(0.7483818531036377, 0.6632681488990784),
		new Float2(-0.728892982006073, -0.6846276521682739),
		new Float2(0.8729032874107361, -0.487893283367157),
		new Float2(0.828834593296051, 0.5594937205314636),
		new Float2(0.08074566721916199, 0.9967347383499146),
		new Float2(0.9799148440361023, -0.19941650331020355),
		new Float2(-0.580730676651001, -0.8140957355499268),
		new Float2(-0.47000497579574585, -0.8826637864112854),
		new Float2(0.24094930291175842, 0.9705377221107483),
		new Float2(0.9437816739082336, -0.33056941628456116),
		new Float2(-0.8927998542785645, -0.4504535496234894),
		new Float2(-0.806962251663208, 0.5906030535697937),
		new Float2(0.06258973479270935, 0.9980393648147583),
		new Float2(-0.9312597513198853, 0.36435598134994507),
		new Float2(0.5777449607849121, 0.8162173628807068),
		new Float2(-0.33600959181785583, -0.9418585896492004),
		new Float2(0.6979320645332336, -0.7161639332771301),
		new Float2(-0.002008157316595316, -0.9999979734420776),
		new Float2(-0.18272943794727325, -0.9831632375717163),
		new Float2(-0.6523911952972412, 0.7578824162483215),
		new Float2(-0.4302626848220825, -0.9027037024497986),
		new Float2(-0.9985126256942749, -0.05452091246843338),
		new Float2(-0.01028102170675993, -0.9999471306800842),
		new Float2(-0.4946071207523346, 0.8691166639328003),
		new Float2(-0.2999350130558014, 0.9539596438407898),
		new Float2(0.8165472149848938, 0.5772786736488342),
		new Float2(0.2697460353374481, 0.9629315137863159),
		new Float2(-0.7306287288665771, -0.6827749609947205),
		new Float2(-0.7590951919555664, -0.6509796380996704),
		new Float2(-0.9070538282394409, 0.42101460695266724),
		new Float2(-0.5104861259460449, -0.8598859906196594),
		new Float2(0.861335039138794, 0.5080373287200928),
		new Float2(0.500788152217865, -0.8655698895454407),
		new Float2(-0.6541581749916077, 0.7563577890396118),
		new Float2(-0.8382755517959595, -0.5452468395233154),
		new Float2(0.6940070986747742, 0.7199681997299194),
		new Float2(0.069509357213974, 0.9975813031196594),
		new Float2(0.17029422521591187, -0.9853932857513428),
		new Float2(0.2695973217487335, 0.9629731178283691),
		new Float2(0.5519612431526184, -0.8338697552680969),
		new Float2(0.22565749287605286, -0.9742066860198975),
		new Float2(0.4215262830257416, -0.9068161845207214),
		new Float2(0.48818734288215637, -0.8727388381958008),
		new Float2(-0.3683854937553406, -0.9296731352806091),
		new Float2(-0.9825390577316284, 0.186056450009346),
		new Float2(0.8125647306442261, 0.5828710198402405),
		new Float2(0.31964609026908875, -0.9475370049476624),
		new Float2(0.9570913910865784, 0.2897862493991852),
		new Float2(-0.6876655220985413, -0.7260276079177856),
		new Float2(-0.9988771080970764, -0.04737672954797745),
		new Float2(-0.1250178962945938, 0.9921544790267944),
		new Float2(-0.8280133605003357, 0.5607083439826965),
		new Float2(0.932486355304718, -0.361205130815506),
		new Float2(0.63946533203125, 0.7688199281692505),
		new Float2(-0.016238471493124962, -0.9998681545257568),
		new Float2(-0.9955014586448669, -0.09474613517522812),
		new Float2(-0.8145331740379333, 0.5801169872283936),
		new Float2(0.4037328064441681, -0.9148769378662109),
		new Float2(0.9944263100624084, 0.10543368011713028),
		new Float2(-0.16247116029262543, 0.9867132902145386),
		new Float2(-0.9949488043785095, -0.10038387775421143),
		new Float2(-0.6995302438735962, 0.7146030068397522),
		new Float2(0.5263414978981018, -0.8502732515335083),
		new Float2(-0.5395221710205078, 0.8419713973999023),
		new Float2(0.6579370498657227, 0.7530729174613953),
		new Float2(0.014267588034272194, -0.9998981952667236),
		new Float2(-0.6734383702278137, 0.7392433285713196),
		new Float2(0.6394121050834656, -0.7688642144203186),
		new Float2(0.9211571216583252, 0.3891908526420593),
		new Float2(-0.1466372162103653, -0.9891903400421143),
		new Float2(-0.782318115234375, 0.6228790879249573),
		new Float2(-0.5039610862731934, -0.8637263774871826),
		new Float2(-0.7743120193481445, -0.6328039765357971)
	};

	private static readonly Float3[] CELL_3D = new Float3[256]
	{
		new Float3(-0.7292736768722534, -0.6618439555168152, 0.17355819046497345),
		new Float3(0.7902920842170715, -0.5480887293815613, -0.27392908930778503),
		new Float3(0.7217578887939453, 0.6226212382316589, -0.3023380935192108),
		new Float3(0.565683126449585, -0.8208298087120056, -0.07900002598762512),
		new Float3(0.760049045085907, -0.5555979609489441, -0.33709996938705444),
		new Float3(0.3713945746421814, 0.5011264681816101, 0.7816254496574402),
		new Float3(-0.12770624458789825, -0.4254438877105713, -0.8959289193153381),
		new Float3(-0.28815609216690063, -0.5815839171409607, 0.7607405781745911),
		new Float3(0.5849561095237732, -0.6628202199935913, -0.46743521094322205),
		new Float3(0.3307171165943146, 0.039165373891592026, 0.9429168701171875),
		new Float3(0.8712121844291687, -0.4113374352455139, -0.26793816685676575),
		new Float3(0.5809810161590576, 0.7021915912628174, 0.4115677773952484),
		new Float3(0.5037568807601929, 0.633005678653717, -0.5878204107284546),
		new Float3(0.44937121868133545, 0.6013901829719543, 0.6606022715568542),
		new Float3(-0.6878404021263123, 0.0901889055967331, -0.7202371954917908),
		new Float3(-0.5958956480026245, -0.6469350457191467, 0.4757976531982422),
		new Float3(-0.5127052068710327, 0.1946921944618225, -0.8361987471580505),
		new Float3(-0.9911507368087769, -0.054102763533592224, -0.12121531367301941),
		new Float3(-0.2149721086025238, 0.9720882177352905, -0.09397608041763306),
		new Float3(-0.7518650889396667, -0.5428057312965393, 0.3742469549179077),
		new Float3(0.5237069129943848, 0.8516377210617065, -0.02107817865908146),
		new Float3(0.6333504915237427, 0.19261671602725983, -0.7495104670524597),
		new Float3(-0.06788241863250732, 0.39983057975769043, 0.9140719175338745),
		new Float3(-0.5538628697395325, -0.47298967838287354, -0.6852129101753235),
		new Float3(-0.7261455655097961, -0.5911991000175476, 0.3509933352470398),
		new Float3(-0.9229274988174438, -0.17828087508678436, 0.3412049412727356),
		new Float3(-0.6968814730644226, 0.6511274576187134, 0.300648033618927),
		new Float3(0.9608044624328613, -0.20983631908893585, -0.18117249011993408),
		new Float3(0.06817146390676498, -0.9743404984474182, 0.21450690925121307),
		new Float3(-0.357728511095047, -0.6697087287902832, -0.6507845520973206),
		new Float3(-0.18686211109161377, 0.7648617029190063, -0.6164974570274353),
		new Float3(-0.6541697382926941, 0.3967914879322052, 0.6439087390899658),
		new Float3(0.6993340253829956, -0.6164538264274597, 0.3618239164352417),
		new Float3(-0.15466657280921936, 0.6291283965110779, 0.7617583274841309),
		new Float3(-0.6841613054275513, -0.2580482065677643, -0.6821542382240295),
		new Float3(0.5383980870246887, 0.42586550116539, 0.7271630167961121),
		new Float3(-0.5026987791061401, -0.7939832806587219, -0.34188368916511536),
		new Float3(0.3202971816062927, 0.28344154357910156, 0.9039195775985718),
		new Float3(0.8683227300643921, -0.000376265641534701, -0.4959995150566101),
		new Float3(0.7911200523376465, -0.08511045575141907, 0.6057105660438538),
		new Float3(-0.040110159665346146, -0.439724862575531, 0.8972364068031311),
		new Float3(0.9145119786262512, 0.3579346239566803, -0.1885487586259842),
		new Float3(-0.961203932762146, -0.27564841508865356, 0.010246668942272663),
		new Float3(0.6510361433029175, -0.28777992725372314, -0.7023778557777405),
		new Float3(-0.20417863130569458, 0.7365237474441528, 0.6448596119880676),
		new Float3(-0.7718263864517212, 0.379062682390213, 0.5104855895042419),
		new Float3(-0.3060082793235779, -0.769298791885376, 0.5608371496200562),
		new Float3(0.4540073275566101, -0.5024843215942383, 0.735789954662323),
		new Float3(0.4816795587539673, 0.6021208167076111, -0.6367380023002625),
		new Float3(0.696198046207428, -0.32221972942352295, 0.6414691805839539),
		new Float3(-0.6532160639762878, -0.6781148910522461, 0.336851567029953),
		new Float3(0.5089301466941833, -0.6154662370681763, -0.6018234491348267),
		new Float3(-0.16359198093414307, -0.9133604764938354, -0.37284088134765625),
		new Float3(0.524080216884613, -0.8437663912773132, 0.11575058847665787),
		new Float3(0.5902587175369263, 0.4983817934989929, -0.6349883675575256),
		new Float3(0.5863227844238281, 0.4947647452354431, 0.6414307951927185),
		new Float3(0.6779335141181946, 0.2341345250606537, 0.6968408823013306),
		new Float3(0.7177054286003113, -0.685897946357727, 0.12017863243818283),
		new Float3(-0.5328819751739502, -0.5205125212669373, 0.6671608090400696),
		new Float3(-0.8654873967170715, -0.0700727105140686, -0.4960053861141205),
		new Float3(-0.2861810028553009, 0.7952089309692383, 0.5345495343208313),
		new Float3(-0.04849529638886452, 0.9810836315155029, -0.18741156160831451),
		new Float3(-0.6358521580696106, 0.6058348417282104, 0.47818002104759216),
		new Float3(0.6254794597625732, -0.28616195917129517, 0.7258696556091309),
		new Float3(-0.2585259974002838, 0.5061949491500854, -0.8227581977844238),
		new Float3(0.021363068372011185, 0.5064016580581665, -0.8620330095291138),
		new Float3(0.2001117765903473, 0.8599263429641724, 0.4695550501346588),
		new Float3(0.47435614466667175, 0.6014984846115112, -0.6427953243255615),
		new Float3(0.662299394607544, -0.5202474594116211, -0.5391680002212524),
		new Float3(0.08084972947835922, -0.6532720327377319, 0.752794086933136),
		new Float3(-0.689368724822998, 0.05928603559732437, 0.7219805121421814),
		new Float3(-0.11218871176242828, -0.9673185348510742, 0.22739525139331818),
		new Float3(0.7344115972518921, 0.5979668498039246, -0.32105329632759094),
		new Float3(0.5789393186569214, -0.24888497591018677, 0.7764570116996765),
		new Float3(0.6988182663917542, 0.3557169735431671, -0.6205791234970093),
		new Float3(-0.8636845350265503, -0.27487713098526, -0.42248260974884033),
		new Float3(-0.42470279335975647, -0.4640880823135376, 0.7773350477218628),
		new Float3(0.5257722735404968, -0.8427017331123352, 0.11583299189805984),
		new Float3(0.9343830347061157, 0.31630247831344604, -0.16395439207553864),
		new Float3(-0.10168363898992538, -0.8057302832603455, -0.5834887623786926),
		new Float3(-0.6529238820075989, 0.50602126121521, -0.5635892748832703),
		new Float3(-0.24652861058712006, -0.9668205976486206, -0.06694497168064117),
		new Float3(-0.9776896834373474, -0.20992505550384521, -0.007368825376033783),
		new Float3(0.773689329624176, 0.5734244585037231, 0.26942381262779236),
		new Float3(-0.6095088124275208, 0.4995678961277008, 0.6155737042427063),
		new Float3(0.5794535279273987, 0.7434546947479248, 0.33392924070358276),
		new Float3(-0.8226211071014404, 0.08142581582069397, 0.5627293586730957),
		new Float3(-0.5103854537010193, 0.47036677598953247, 0.7199040055274963),
		new Float3(-0.5764971971511841, -0.07231656461954117, -0.813892662525177),
		new Float3(0.725062906742096, 0.39499714970588684, -0.5641463398933411),
		new Float3(-0.15254239737987518, 0.48608407378196716, -0.8604958057403564),
		new Float3(-0.5550976395606995, -0.4957820773124695, 0.6678823232650757),
		new Float3(-0.18836143612861633, 0.9145869612693787, 0.35784173011779785),
		new Float3(0.7625556588172913, -0.5414408445358276, -0.3540489673614502),
		new Float3(-0.5870231986045837, -0.3226498067378998, -0.7424963712692261),
		new Float3(0.30511242151260376, 0.226254403591156, -0.925048828125),
		new Float3(0.6379576325416565, 0.5772424340248108, -0.5097070336341858),
		new Float3(-0.5966776013374329, 0.14548523724079132, -0.7891830801963806),
		new Float3(-0.6583305597305298, 0.6555487513542175, -0.36994147300720215),
		new Float3(0.7434892654418945, 0.23510846495628357, 0.6260573267936707),
		new Float3(0.5562114119529724, 0.8264360427856445, -0.08736328780651093),
		new Float3(-0.3028939962387085, -0.8251526951789856, 0.47684192657470703),
		new Float3(0.11293438076972961, -0.9858884215354919, -0.12357107549905777),
		new Float3(0.5937653183937073, -0.5896813869476318, 0.5474656820297241),
		new Float3(0.675796389579773, -0.5835758447647095, -0.4502648413181305),
		new Float3(0.7242302894592285, -0.11527197808027267, 0.6798550486564636),
		new Float3(-0.9511914253234863, 0.07536239922046661, -0.2992580831050873),
		new Float3(0.25394710898399353, -0.18863393366336823, 0.9486454129219055),
		new Float3(0.5714336037635803, -0.16794508695602417, -0.8032795786857605),
		new Float3(-0.06778234988451004, 0.3978269398212433, 0.9149531722068787),
		new Float3(0.6074972748756409, 0.7330600023269653, -0.3058922588825226),
		new Float3(-0.5435478687286377, 0.16758224368095398, 0.8224791288375854),
		new Float3(-0.5876678228378296, -0.3380044996738434, -0.7351186871528625),
		new Float3(-0.7967562675476074, 0.04097822681069374, -0.6029098629951477),
		new Float3(-0.1996350884437561, 0.8706294894218445, 0.449611097574234),
		new Float3(-0.027876602485775948, -0.9106232523918152, -0.41229620575904846),
		new Float3(-0.7797626256942749, -0.625763475894928, 0.01975775510072708),
		new Float3(-0.5211232900619507, 0.7401644587516785, -0.42495545744895935),
		new Float3(0.8575425148010254, 0.40532729029655457, -0.316750168800354),
		new Float3(0.10452233254909515, 0.8390195965766907, -0.5339674353599548),
		new Float3(0.35018229484558105, 0.9242523908615112, -0.15208502113819122),
		new Float3(0.1987849920988083, 0.07647613435983658, 0.9770547151565552),
		new Float3(0.7845996618270874, 0.6066256761550903, -0.12809641659259796),
		new Float3(0.09006737172603607, -0.9750989675521851, -0.20265690982341766),
		new Float3(-0.8274343609809875, -0.5422995686531067, 0.14582036435604095),
		new Float3(-0.3485797643661499, -0.4158022701740265, 0.8400003910064697),
		new Float3(-0.24717789888381958, -0.7304819822311401, -0.6366310715675354),
		new Float3(-0.3700155019760132, 0.8577948212623596, 0.3567584455013275),
		new Float3(0.5913394689559937, -0.5483119487762451, -0.591330349445343),
		new Float3(0.12048735469579697, -0.7626472115516663, -0.6354935169219971),
		new Float3(0.616959273815155, 0.030796479433774948, 0.7863922715187073),
		new Float3(0.12581568956375122, -0.6640830039978027, -0.7369967699050903),
		new Float3(-0.6477565169334412, -0.17401473224163055, -0.7417077422142029),
		new Float3(0.6217889189720154, -0.7804430723190308, -0.06547655165195465),
		new Float3(0.6589943170547485, -0.6096987724304199, 0.4404473602771759),
		new Float3(-0.26898375153541565, -0.6732403039932251, -0.6887635588645935),
		new Float3(-0.3849775195121765, 0.5676542520523071, 0.7277094125747681),
		new Float3(0.5754444599151611, 0.8110471367835999, -0.10519634932279587),
		new Float3(0.91415935754776, 0.3832947909832001, 0.13190056383609772),
		new Float3(-0.10792531818151474, 0.924549400806427, 0.3654593527317047),
		new Float3(0.3779771029949188, 0.30431488156318665, 0.8743716478347778),
		new Float3(-0.21428851783275604, -0.8259286284446716, 0.5214617252349854),
		new Float3(0.5802544355392456, 0.41480985283851624, -0.7008833885192871),
		new Float3(-0.19826608896255493, 0.8567161560058594, -0.4761596620082855),
		new Float3(-0.03381553664803505, 0.3773180842399597, -0.9254661202430725),
		new Float3(-0.686792254447937, -0.6656597852706909, 0.29191336035728455),
		new Float3(0.7731742858886719, -0.28757935762405396, -0.5652430057525635),
		new Float3(-0.09655942022800446, 0.9193708300590515, -0.38135749101638794),
		new Float3(0.27157023549079895, -0.9577909708023071, -0.09426605701446533),
		new Float3(0.24510157108306885, -0.6917998790740967, -0.6792188286781311),
		new Float3(0.9777007699012756, -0.17538553476333618, 0.11550365388393402),
		new Float3(-0.5224739909172058, 0.8521606922149658, 0.029036158695816994),
		new Float3(-0.7734880447387695, -0.5261292457580566, 0.3534179627895355),
		new Float3(-0.713449239730835, -0.2695472538471222, 0.6467878222465515),
		new Float3(0.16440372169017792, 0.5105845928192139, -0.8439637422561646),
		new Float3(0.6494635939598083, 0.05585611239075661, 0.7583383917808533),
		new Float3(-0.47119709849357605, 0.5017280578613281, -0.7254256010055542),
		new Float3(-0.6335764527320862, -0.2381686270236969, -0.7361090779304504),
		new Float3(-0.9021533131599426, -0.27094781398773193, -0.33571818470954895),
		new Float3(-0.37937110662460327, 0.8722581267356873, 0.30861520767211914),
		new Float3(-0.685559868812561, -0.3250143229961395, 0.6514394283294678),
		new Float3(0.2900942265987396, -0.7799057960510254, -0.5546100735664368),
		new Float3(-0.20983193814754486, 0.8503707051277161, 0.48253515362739563),
		new Float3(-0.45926037430763245, 0.6598504185676575, -0.594707727432251),
		new Float3(0.8715945482254028, 0.09616365283727646, -0.48070311546325684),
		new Float3(-0.6776666045188904, 0.7118504643440247, -0.18449069559574127),
		new Float3(0.704437792301178, 0.3124276101589203, 0.6373040080070496),
		new Float3(-0.7052319049835205, -0.24010932445526123, -0.6670798063278198),
		new Float3(0.08192100375890732, -0.720733642578125, -0.6883545517921448),
		new Float3(-0.6993681192398071, -0.5875763297080994, -0.40698689222335815),
		new Float3(-0.12814544141292572, 0.6419895887374878, 0.755928635597229),
		new Float3(-0.6337388157844543, -0.6785471439361572, -0.3714146912097931),
		new Float3(0.5565052032470703, -0.21688875555992126, -0.8020356893539429),
		new Float3(-0.579155445098877, 0.7244371771812439, -0.37385788559913635),
		new Float3(0.11757791042327881, -0.7096450924873352, 0.6946792602539062),
		new Float3(-0.613461971282959, 0.13236311078071594, 0.778552770614624),
		new Float3(0.6984635591506958, -0.02980516292154789, -0.7150247097015381),
		new Float3(0.8318082690238953, -0.3930172026157379, 0.3919597566127777),
		new Float3(0.1469576358795166, 0.055416516959667206, -0.9875892400741577),
		new Float3(0.7088685631752014, -0.26905038952827454, 0.6520101428031921),
		new Float3(0.2726053297519684, 0.6736976504325867, -0.6868899464607239),
		new Float3(-0.6591295599937439, 0.30354586243629456, -0.6880466341972351),
		new Float3(0.4815131425857544, -0.752826988697052, 0.4487723112106323),
		new Float3(0.9430009722709656, 0.1675647348165512, -0.28752613067626953),
		new Float3(0.43480294942855835, 0.7695304751396179, -0.46772778034210205),
		new Float3(0.393199622631073, 0.5944736003875732, 0.7014236450195312),
		new Float3(0.7254336476325989, -0.6039256453514099, 0.3301814794540405),
		new Float3(0.7590235471725464, -0.6506083011627197, 0.024333132430911064),
		new Float3(-0.855276882648468, -0.3430042862892151, 0.3883935809135437),
		new Float3(-0.6139746904373169, 0.6981725096702576, 0.36822575330734253),
		new Float3(-0.7465905547142029, -0.5752009749412537, 0.3342849314212799),
		new Float3(0.5730065703392029, 0.8105555176734924, -0.12109167873859406),
		new Float3(-0.9225877523422241, -0.3475210964679718, -0.16751404106616974),
		new Float3(-0.7105816602706909, -0.47196921706199646, -0.5218417048454285),
		new Float3(-0.08564610034227371, 0.3583001494407654, 0.9296696782112122),
		new Float3(-0.8279697895050049, -0.20431570708751678, 0.5222271084785461),
		new Float3(0.42794403433799744, 0.2781659960746765, 0.8599346280097961),
		new Float3(0.5399079918861389, -0.7857120633125305, -0.30192041397094727),
		new Float3(0.5678403973579407, -0.5495414137840271, -0.6128307580947876),
		new Float3(-0.9896070957183838, 0.13656391203403473, -0.04503418505191803),
		new Float3(-0.6154342889785767, -0.644087553024292, 0.4543037414550781),
		new Float3(0.1074204370379448, -0.7946340441703796, 0.5975094437599182),
		new Float3(-0.3595449924468994, -0.8885530233383179, 0.2849578261375427),
		new Float3(-0.21804052591323853, 0.15298889577388763, 0.9638738036155701),
		new Float3(-0.7277432084083557, -0.6164050698280334, -0.30072346329689026),
		new Float3(0.7249729037284851, -0.006697194650769234, 0.688744843006134),
		new Float3(-0.5553659200668335, -0.5336586236953735, 0.6377907991409302),
		new Float3(0.5137557983398438, 0.7976208329200745, -0.3160000145435333),
		new Float3(-0.3794024884700775, 0.9245608448982239, -0.035227514803409576),
		new Float3(0.8229248523712158, 0.2745365798473358, -0.4974176585674286),
		new Float3(-0.5404114127159119, 0.6091141700744629, 0.5804613828659058),
		new Float3(0.8036581873893738, -0.270302951335907, 0.5301601886749268),
		new Float3(0.6044318675994873, 0.6832968592643738, 0.40959432721138),
		new Float3(0.06389988958835602, 0.965820848941803, -0.2512108087539673),
		new Float3(0.10871133208274841, 0.7402471303939819, -0.6634877920150757),
		new Float3(-0.713427722454071, -0.6926783919334412, 0.10591284930706024),
		new Float3(0.6458897590637207, -0.5724548697471619, -0.5050958395004272),
		new Float3(-0.655393123626709, 0.7381471395492554, 0.15999561548233032),
		new Float3(0.3910961449146271, 0.9188871383666992, -0.05186755955219269),
		new Float3(-0.4879022538661957, -0.5904377102851868, 0.6429111361503601),
		new Float3(0.6014789938926697, 0.7707441449165344, -0.21018201112747192),
		new Float3(-0.5677173137664795, 0.7511361241340637, 0.3368851840496063),
		new Float3(0.7858573794364929, 0.2266746610403061, 0.5753666758537292),
		new Float3(-0.4520345628261566, -0.6042227149009705, -0.6561857461929321),
		new Float3(0.0022721162531524897, 0.41328439116477966, -0.9105991721153259),
		new Float3(-0.5815751552581787, -0.5162925720214844, 0.6286591291427612),
		new Float3(-0.03703704848885536, 0.8273785710334778, 0.5604221224784851),
		new Float3(-0.511969268321991, 0.7953543663024902, -0.3244979977607727),
		new Float3(-0.2682417333126068, -0.9572290182113647, -0.10843876004219055),
		new Float3(-0.23224827647209167, -0.9679130911827087, -0.0959424301981926),
		new Float3(0.3554328978061676, -0.8881505727767944, 0.29130062460899353),
		new Float3(0.734652042388916, -0.43713730573654175, 0.5188422799110413),
		new Float3(0.9985120296478271, 0.046590112149715424, -0.0283394455909729),
		new Float3(-0.372768759727478, -0.9082481265068054, 0.19007572531700134),
		new Float3(0.917373776435852, -0.3483642041683197, 0.1925298422574997),
		new Float3(0.2714911103248596, 0.4147529602050781, -0.8684886693954468),
		new Float3(0.5131763219833374, -0.7116334438323975, 0.47982069849967957),
		new Float3(-0.8737353682518005, 0.1888699233531952, -0.44823506474494934),
		new Float3(0.8460043668746948, -0.3725217878818512, 0.38144999742507935),
		new Float3(0.8978727459907532, -0.1780209094285965, -0.40265753865242004),
		new Float3(0.21780656278133392, -0.9698323011398315, -0.10947895050048828),
		new Float3(-0.1518031358718872, -0.7788918018341064, -0.6085091233253479),
		new Float3(-0.26003849506378174, -0.47553980350494385, -0.8403819799423218),
		new Float3(0.5723134875297546, -0.7474340796470642, -0.337341845035553),
		new Float3(-0.7174140810966492, 0.16990171372890472, -0.675611138343811),
		new Float3(-0.6841807961463928, 0.02145707607269287, -0.728996753692627),
		new Float3(-0.20074479281902313, 0.06555605679750443, -0.9774476885795593),
		new Float3(-0.11488036811351776, -0.8044887185096741, 0.5827524065971375),
		new Float3(-0.7870349884033203, 0.03447489067912102, 0.6159443259239197),
		new Float3(-0.2015596479177475, 0.6859872341156006, 0.6991389393806458),
		new Float3(-0.0858108252286911, -0.1092083603143692, -0.9903080463409424),
		new Float3(0.5532693266868591, 0.7325250506401062, -0.3966107666492462),
		new Float3(-0.1842489391565323, -0.9777374863624573, -0.100407674908638),
		new Float3(0.07754737883806229, -0.9111505746841431, 0.4047110378742218),
		new Float3(0.13998384773731232, 0.7601631283760071, -0.634473443031311),
		new Float3(0.44844192266464233, -0.8452892303466797, 0.29049253463745117)
	};

	private const int X_PRIME = 1619;

	private const int Y_PRIME = 31337;

	private const int Z_PRIME = 6971;

	private const int W_PRIME = 1013;

	private const double F3 = 1.0 / 3.0;

	private const double G3 = 1.0 / 6.0;

	private const double G33 = -0.5;

	private const double F2 = 0.5;

	private const double G2 = 0.25;

	private static readonly byte[] SIMPLEX_4D = new byte[256]
	{
		0, 1, 2, 3, 0, 1, 3, 2, 0, 0,
		0, 0, 0, 2, 3, 1, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 1, 2,
		3, 0, 0, 2, 1, 3, 0, 0, 0, 0,
		0, 3, 1, 2, 0, 3, 2, 1, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		1, 3, 2, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 1, 2, 0, 3,
		0, 0, 0, 0, 1, 3, 0, 2, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		2, 3, 0, 1, 2, 3, 1, 0, 1, 0,
		2, 3, 1, 0, 3, 2, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 2, 0,
		3, 1, 0, 0, 0, 0, 2, 1, 3, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 0, 2, 0, 1, 3, 0, 0, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 3, 0,
		1, 2, 3, 0, 2, 1, 0, 0, 0, 0,
		3, 1, 2, 0, 2, 1, 0, 3, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
		3, 1, 0, 2, 0, 0, 0, 0, 3, 2,
		0, 1, 3, 2, 1, 0
	};

	private const double F4 = 0.30901699250000003;

	private const double G4 = 0.1381966015;

	private const double CUBIC_3D_BOUNDING = 8.0 / 27.0;

	private const double CUBIC_2D_BOUNDING = 4.0 / 9.0;

	public FastNoise(int seed = 1337)
	{
		m_seed = seed;
		CalculateFractalBounding();
	}

	public static double GetDecimalType()
	{
		return 0.0;
	}

	public int GetSeed()
	{
		return m_seed;
	}

	public void SetSeed(int seed)
	{
		m_seed = seed;
	}

	public void SetFrequency(double frequency)
	{
		m_frequency = frequency;
	}

	public void SetInterp(Interp interp)
	{
		m_interp = interp;
	}

	public void SetNoiseType(NoiseType noiseType)
	{
		m_noiseType = noiseType;
	}

	public void SetFractalOctaves(int octaves)
	{
		m_octaves = octaves;
		CalculateFractalBounding();
	}

	public void SetFractalLacunarity(double lacunarity)
	{
		m_lacunarity = lacunarity;
	}

	public void SetFractalGain(double gain)
	{
		m_gain = gain;
		CalculateFractalBounding();
	}

	public void SetFractalType(FractalType fractalType)
	{
		m_fractalType = fractalType;
	}

	public void SetCellularDistanceFunction(CellularDistanceFunction cellularDistanceFunction)
	{
		m_cellularDistanceFunction = cellularDistanceFunction;
	}

	public void SetCellularReturnType(CellularReturnType cellularReturnType)
	{
		m_cellularReturnType = cellularReturnType;
	}

	public void SetCellularDistance2Indicies(int cellularDistanceIndex0, int cellularDistanceIndex1)
	{
		m_cellularDistanceIndex0 = Math.Min(cellularDistanceIndex0, cellularDistanceIndex1);
		m_cellularDistanceIndex1 = Math.Max(cellularDistanceIndex0, cellularDistanceIndex1);
		m_cellularDistanceIndex0 = Math.Min(Math.Max(m_cellularDistanceIndex0, 0), 3);
		m_cellularDistanceIndex1 = Math.Min(Math.Max(m_cellularDistanceIndex1, 0), 3);
	}

	public void SetCellularJitter(float cellularJitter)
	{
		m_cellularJitter = cellularJitter;
	}

	public void SetCellularNoiseLookup(FastNoise noise)
	{
		m_cellularNoiseLookup = noise;
	}

	public void SetGradientPerturbAmp(double gradientPerturbAmp)
	{
		m_gradientPerturbAmp = gradientPerturbAmp;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private static int FastFloor(double f)
	{
		if (!(f >= 0.0))
		{
			return (int)f - 1;
		}
		return (int)f;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private static int FastRound(double f)
	{
		if (!(f >= 0.0))
		{
			return (int)(f - 0.5);
		}
		return (int)(f + 0.5);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private static double Lerp(double a, double b, double t)
	{
		return a + t * (b - a);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private static double InterpHermiteFunc(double t)
	{
		return t * t * (3.0 - 2.0 * t);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private static double InterpQuinticFunc(double t)
	{
		return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private static double CubicLerp(double a, double b, double c, double d, double t)
	{
		double num = d - c - (a - b);
		return t * t * t * num + t * t * (a - b - num) + t * (c - a) + b;
	}

	private void CalculateFractalBounding()
	{
		double num = m_gain;
		double num2 = 1.0;
		for (int i = 1; i < m_octaves; i++)
		{
			num2 += num;
			num *= m_gain;
		}
		m_fractalBounding = 1.0 / num2;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private static int Hash2D(int seed, int x, int y)
	{
		int num = seed;
		num ^= 1619 * x;
		num ^= 31337 * y;
		num = num * num * num * 60493;
		return (num >> 13) ^ num;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private static int Hash3D(int seed, int x, int y, int z)
	{
		int num = seed;
		num ^= 1619 * x;
		num ^= 31337 * y;
		num ^= 6971 * z;
		num = num * num * num * 60493;
		return (num >> 13) ^ num;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private static int Hash4D(int seed, int x, int y, int z, int w)
	{
		int num = seed;
		num ^= 1619 * x;
		num ^= 31337 * y;
		num ^= 6971 * z;
		num ^= 1013 * w;
		num = num * num * num * 60493;
		return (num >> 13) ^ num;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private static double ValCoord2D(int seed, int x, int y)
	{
		int num = seed;
		num ^= 1619 * x;
		num ^= 31337 * y;
		return (double)(num * num * num * 60493) / 2147483648.0;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private static double ValCoord3D(int seed, int x, int y, int z)
	{
		int num = seed;
		num ^= 1619 * x;
		num ^= 31337 * y;
		num ^= 6971 * z;
		return (double)(num * num * num * 60493) / 2147483648.0;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private static double ValCoord4D(int seed, int x, int y, int z, int w)
	{
		int num = seed;
		num ^= 1619 * x;
		num ^= 31337 * y;
		num ^= 6971 * z;
		num ^= 1013 * w;
		return (double)(num * num * num * 60493) / 2147483648.0;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private static double GradCoord2D(int seed, int x, int y, double xd, double yd)
	{
		int num = seed;
		num ^= 1619 * x;
		num ^= 31337 * y;
		num = num * num * num * 60493;
		num = (num >> 13) ^ num;
		Float2 @float = GRAD_2D[num & 7];
		return xd * @float.x + yd * @float.y;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private static double GradCoord3D(int seed, int x, int y, int z, double xd, double yd, double zd)
	{
		int num = seed;
		num ^= 1619 * x;
		num ^= 31337 * y;
		num ^= 6971 * z;
		num = num * num * num * 60493;
		num = (num >> 13) ^ num;
		Float3 @float = GRAD_3D[num & 0xF];
		return xd * @float.x + yd * @float.y + zd * @float.z;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private static double GradCoord4D(int seed, int x, int y, int z, int w, double xd, double yd, double zd, double wd)
	{
		int num = seed;
		num ^= 1619 * x;
		num ^= 31337 * y;
		num ^= 6971 * z;
		num ^= 1013 * w;
		num = num * num * num * 60493;
		num = (num >> 13) ^ num;
		num &= 0x1F;
		double num2 = yd;
		double num3 = zd;
		double num4 = wd;
		switch (num >> 3)
		{
		case 1:
			num2 = wd;
			num3 = xd;
			num4 = yd;
			break;
		case 2:
			num2 = zd;
			num3 = wd;
			num4 = xd;
			break;
		case 3:
			num2 = yd;
			num3 = zd;
			num4 = wd;
			break;
		}
		return (((num & 4) == 0) ? (0.0 - num2) : num2) + (((num & 2) == 0) ? (0.0 - num3) : num3) + (((num & 1) == 0) ? (0.0 - num4) : num4);
	}

	public double GetNoise(double x, double y, double z)
	{
		x *= m_frequency;
		y *= m_frequency;
		z *= m_frequency;
		switch (m_noiseType)
		{
		case NoiseType.Value:
			return SingleValue(m_seed, x, y, z);
		case NoiseType.ValueFractal:
			return m_fractalType switch
			{
				FractalType.FBM => SingleValueFractalFBM(x, y, z), 
				FractalType.Billow => SingleValueFractalBillow(x, y, z), 
				FractalType.RigidMulti => SingleValueFractalRigidMulti(x, y, z), 
				_ => 0.0, 
			};
		case NoiseType.Perlin:
			return SinglePerlin(m_seed, x, y, z);
		case NoiseType.PerlinFractal:
			return m_fractalType switch
			{
				FractalType.FBM => SinglePerlinFractalFBM(x, y, z), 
				FractalType.Billow => SinglePerlinFractalBillow(x, y, z), 
				FractalType.RigidMulti => SinglePerlinFractalRigidMulti(x, y, z), 
				_ => 0.0, 
			};
		case NoiseType.Simplex:
			return SingleSimplex(m_seed, x, y, z);
		case NoiseType.SimplexFractal:
			return m_fractalType switch
			{
				FractalType.FBM => SingleSimplexFractalFBM(x, y, z), 
				FractalType.Billow => SingleSimplexFractalBillow(x, y, z), 
				FractalType.RigidMulti => SingleSimplexFractalRigidMulti(x, y, z), 
				_ => 0.0, 
			};
		case NoiseType.Cellular:
		{
			CellularReturnType cellularReturnType = m_cellularReturnType;
			if ((uint)cellularReturnType <= 2u)
			{
				return SingleCellular(x, y, z);
			}
			return SingleCellular2Edge(x, y, z);
		}
		case NoiseType.WhiteNoise:
			return GetWhiteNoise(x, y, z);
		case NoiseType.Cubic:
			return SingleCubic(m_seed, x, y, z);
		case NoiseType.CubicFractal:
			return m_fractalType switch
			{
				FractalType.FBM => SingleCubicFractalFBM(x, y, z), 
				FractalType.Billow => SingleCubicFractalBillow(x, y, z), 
				FractalType.RigidMulti => SingleCubicFractalRigidMulti(x, y, z), 
				_ => 0.0, 
			};
		default:
			return 0.0;
		}
	}

	public double GetNoise(double x, double y)
	{
		x *= m_frequency;
		y *= m_frequency;
		switch (m_noiseType)
		{
		case NoiseType.Value:
			return SingleValue(m_seed, x, y);
		case NoiseType.ValueFractal:
			return m_fractalType switch
			{
				FractalType.FBM => SingleValueFractalFBM(x, y), 
				FractalType.Billow => SingleValueFractalBillow(x, y), 
				FractalType.RigidMulti => SingleValueFractalRigidMulti(x, y), 
				_ => 0.0, 
			};
		case NoiseType.Perlin:
			return SinglePerlin(m_seed, x, y);
		case NoiseType.PerlinFractal:
			return m_fractalType switch
			{
				FractalType.FBM => SinglePerlinFractalFBM(x, y), 
				FractalType.Billow => SinglePerlinFractalBillow(x, y), 
				FractalType.RigidMulti => SinglePerlinFractalRigidMulti(x, y), 
				_ => 0.0, 
			};
		case NoiseType.Simplex:
			return SingleSimplex(m_seed, x, y);
		case NoiseType.SimplexFractal:
			return m_fractalType switch
			{
				FractalType.FBM => SingleSimplexFractalFBM(x, y), 
				FractalType.Billow => SingleSimplexFractalBillow(x, y), 
				FractalType.RigidMulti => SingleSimplexFractalRigidMulti(x, y), 
				_ => 0.0, 
			};
		case NoiseType.Cellular:
		{
			CellularReturnType cellularReturnType = m_cellularReturnType;
			if ((uint)cellularReturnType <= 2u)
			{
				return SingleCellular(x, y);
			}
			return SingleCellular2Edge(x, y);
		}
		case NoiseType.WhiteNoise:
			return GetWhiteNoise(x, y);
		case NoiseType.Cubic:
			return SingleCubic(m_seed, x, y);
		case NoiseType.CubicFractal:
			return m_fractalType switch
			{
				FractalType.FBM => SingleCubicFractalFBM(x, y), 
				FractalType.Billow => SingleCubicFractalBillow(x, y), 
				FractalType.RigidMulti => SingleCubicFractalRigidMulti(x, y), 
				_ => 0.0, 
			};
		default:
			return 0.0;
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private int FloatCast2Int(double f)
	{
		long num = BitConverter.DoubleToInt64Bits(f);
		return (int)(num ^ (num >> 32));
	}

	public double GetWhiteNoise(double x, double y, double z, double w)
	{
		int x2 = FloatCast2Int(x);
		int y2 = FloatCast2Int(y);
		int z2 = FloatCast2Int(z);
		int w2 = FloatCast2Int(w);
		return ValCoord4D(m_seed, x2, y2, z2, w2);
	}

	public double GetWhiteNoise(double x, double y, double z)
	{
		int x2 = FloatCast2Int(x);
		int y2 = FloatCast2Int(y);
		int z2 = FloatCast2Int(z);
		return ValCoord3D(m_seed, x2, y2, z2);
	}

	public double GetWhiteNoise(double x, double y)
	{
		int x2 = FloatCast2Int(x);
		int y2 = FloatCast2Int(y);
		return ValCoord2D(m_seed, x2, y2);
	}

	public double GetWhiteNoiseInt(int x, int y, int z, int w)
	{
		return ValCoord4D(m_seed, x, y, z, w);
	}

	public double GetWhiteNoiseInt(int x, int y, int z)
	{
		return ValCoord3D(m_seed, x, y, z);
	}

	public double GetWhiteNoiseInt(int x, int y)
	{
		return ValCoord2D(m_seed, x, y);
	}

	public double GetValueFractal(double x, double y, double z)
	{
		x *= m_frequency;
		y *= m_frequency;
		z *= m_frequency;
		return m_fractalType switch
		{
			FractalType.FBM => SingleValueFractalFBM(x, y, z), 
			FractalType.Billow => SingleValueFractalBillow(x, y, z), 
			FractalType.RigidMulti => SingleValueFractalRigidMulti(x, y, z), 
			_ => 0.0, 
		};
	}

	private double SingleValueFractalFBM(double x, double y, double z)
	{
		int num = m_seed;
		double num2 = SingleValue(num, x, y, z);
		double num3 = 1.0;
		for (int i = 1; i < m_octaves; i++)
		{
			x *= m_lacunarity;
			y *= m_lacunarity;
			z *= m_lacunarity;
			num3 *= m_gain;
			num2 += SingleValue(++num, x, y, z) * num3;
		}
		return num2 * m_fractalBounding;
	}

	private double SingleValueFractalBillow(double x, double y, double z)
	{
		int num = m_seed;
		double num2 = Math.Abs(SingleValue(num, x, y, z)) * 2.0 - 1.0;
		double num3 = 1.0;
		for (int i = 1; i < m_octaves; i++)
		{
			x *= m_lacunarity;
			y *= m_lacunarity;
			z *= m_lacunarity;
			num3 *= m_gain;
			num2 += (Math.Abs(SingleValue(++num, x, y, z)) * 2.0 - 1.0) * num3;
		}
		return num2 * m_fractalBounding;
	}

	private double SingleValueFractalRigidMulti(double x, double y, double z)
	{
		int num = m_seed;
		double num2 = 1.0 - Math.Abs(SingleValue(num, x, y, z));
		double num3 = 1.0;
		for (int i = 1; i < m_octaves; i++)
		{
			x *= m_lacunarity;
			y *= m_lacunarity;
			z *= m_lacunarity;
			num3 *= m_gain;
			num2 -= (1.0 - Math.Abs(SingleValue(++num, x, y, z))) * num3;
		}
		return num2;
	}

	public double GetValue(double x, double y, double z)
	{
		return SingleValue(m_seed, x * m_frequency, y * m_frequency, z * m_frequency);
	}

	private double SingleValue(int seed, double x, double y, double z)
	{
		int num = FastFloor(x);
		int num2 = FastFloor(y);
		int num3 = FastFloor(z);
		int x2 = num + 1;
		int y2 = num2 + 1;
		int z2 = num3 + 1;
		double t;
		double t2;
		double t3;
		switch (m_interp)
		{
		default:
			t = x - (double)num;
			t2 = y - (double)num2;
			t3 = z - (double)num3;
			break;
		case Interp.Hermite:
			t = InterpHermiteFunc(x - (double)num);
			t2 = InterpHermiteFunc(y - (double)num2);
			t3 = InterpHermiteFunc(z - (double)num3);
			break;
		case Interp.Quintic:
			t = InterpQuinticFunc(x - (double)num);
			t2 = InterpQuinticFunc(y - (double)num2);
			t3 = InterpQuinticFunc(z - (double)num3);
			break;
		}
		double a = Lerp(ValCoord3D(seed, num, num2, num3), ValCoord3D(seed, x2, num2, num3), t);
		double b = Lerp(ValCoord3D(seed, num, y2, num3), ValCoord3D(seed, x2, y2, num3), t);
		double a2 = Lerp(ValCoord3D(seed, num, num2, z2), ValCoord3D(seed, x2, num2, z2), t);
		double b2 = Lerp(ValCoord3D(seed, num, y2, z2), ValCoord3D(seed, x2, y2, z2), t);
		double a3 = Lerp(a, b, t2);
		double b3 = Lerp(a2, b2, t2);
		return Lerp(a3, b3, t3);
	}

	public double GetValueFractal(double x, double y)
	{
		x *= m_frequency;
		y *= m_frequency;
		return m_fractalType switch
		{
			FractalType.FBM => SingleValueFractalFBM(x, y), 
			FractalType.Billow => SingleValueFractalBillow(x, y), 
			FractalType.RigidMulti => SingleValueFractalRigidMulti(x, y), 
			_ => 0.0, 
		};
	}

	private double SingleValueFractalFBM(double x, double y)
	{
		int num = m_seed;
		double num2 = SingleValue(num, x, y);
		double num3 = 1.0;
		for (int i = 1; i < m_octaves; i++)
		{
			x *= m_lacunarity;
			y *= m_lacunarity;
			num3 *= m_gain;
			num2 += SingleValue(++num, x, y) * num3;
		}
		return num2 * m_fractalBounding;
	}

	private double SingleValueFractalBillow(double x, double y)
	{
		int num = m_seed;
		double num2 = Math.Abs(SingleValue(num, x, y)) * 2.0 - 1.0;
		double num3 = 1.0;
		for (int i = 1; i < m_octaves; i++)
		{
			x *= m_lacunarity;
			y *= m_lacunarity;
			num3 *= m_gain;
			num2 += (Math.Abs(SingleValue(++num, x, y)) * 2.0 - 1.0) * num3;
		}
		return num2 * m_fractalBounding;
	}

	private double SingleValueFractalRigidMulti(double x, double y)
	{
		int num = m_seed;
		double num2 = 1.0 - Math.Abs(SingleValue(num, x, y));
		double num3 = 1.0;
		for (int i = 1; i < m_octaves; i++)
		{
			x *= m_lacunarity;
			y *= m_lacunarity;
			num3 *= m_gain;
			num2 -= (1.0 - Math.Abs(SingleValue(++num, x, y))) * num3;
		}
		return num2;
	}

	public double GetValue(double x, double y)
	{
		return SingleValue(m_seed, x * m_frequency, y * m_frequency);
	}

	private double SingleValue(int seed, double x, double y)
	{
		int num = FastFloor(x);
		int num2 = FastFloor(y);
		int x2 = num + 1;
		int y2 = num2 + 1;
		double t;
		double t2;
		switch (m_interp)
		{
		default:
			t = x - (double)num;
			t2 = y - (double)num2;
			break;
		case Interp.Hermite:
			t = InterpHermiteFunc(x - (double)num);
			t2 = InterpHermiteFunc(y - (double)num2);
			break;
		case Interp.Quintic:
			t = InterpQuinticFunc(x - (double)num);
			t2 = InterpQuinticFunc(y - (double)num2);
			break;
		}
		double a = Lerp(ValCoord2D(seed, num, num2), ValCoord2D(seed, x2, num2), t);
		double b = Lerp(ValCoord2D(seed, num, y2), ValCoord2D(seed, x2, y2), t);
		return Lerp(a, b, t2);
	}

	public double GetPerlinFractal(double x, double y, double z)
	{
		x *= m_frequency;
		y *= m_frequency;
		z *= m_frequency;
		return m_fractalType switch
		{
			FractalType.FBM => SinglePerlinFractalFBM(x, y, z), 
			FractalType.Billow => SinglePerlinFractalBillow(x, y, z), 
			FractalType.RigidMulti => SinglePerlinFractalRigidMulti(x, y, z), 
			_ => 0.0, 
		};
	}

	private double SinglePerlinFractalFBM(double x, double y, double z)
	{
		int num = m_seed;
		double num2 = SinglePerlin(num, x, y, z);
		double num3 = 1.0;
		for (int i = 1; i < m_octaves; i++)
		{
			x *= m_lacunarity;
			y *= m_lacunarity;
			z *= m_lacunarity;
			num3 *= m_gain;
			num2 += SinglePerlin(++num, x, y, z) * num3;
		}
		return num2 * m_fractalBounding;
	}

	private double SinglePerlinFractalBillow(double x, double y, double z)
	{
		int num = m_seed;
		double num2 = Math.Abs(SinglePerlin(num, x, y, z)) * 2.0 - 1.0;
		double num3 = 1.0;
		for (int i = 1; i < m_octaves; i++)
		{
			x *= m_lacunarity;
			y *= m_lacunarity;
			z *= m_lacunarity;
			num3 *= m_gain;
			num2 += (Math.Abs(SinglePerlin(++num, x, y, z)) * 2.0 - 1.0) * num3;
		}
		return num2 * m_fractalBounding;
	}

	private double SinglePerlinFractalRigidMulti(double x, double y, double z)
	{
		int num = m_seed;
		double num2 = 1.0 - Math.Abs(SinglePerlin(num, x, y, z));
		double num3 = 1.0;
		for (int i = 1; i < m_octaves; i++)
		{
			x *= m_lacunarity;
			y *= m_lacunarity;
			z *= m_lacunarity;
			num3 *= m_gain;
			num2 -= (1.0 - Math.Abs(SinglePerlin(++num, x, y, z))) * num3;
		}
		return num2;
	}

	public double GetPerlin(double x, double y, double z)
	{
		return SinglePerlin(m_seed, x * m_frequency, y * m_frequency, z * m_frequency);
	}

	private double SinglePerlin(int seed, double x, double y, double z)
	{
		int num = FastFloor(x);
		int num2 = FastFloor(y);
		int num3 = FastFloor(z);
		int x2 = num + 1;
		int y2 = num2 + 1;
		int z2 = num3 + 1;
		double t;
		double t2;
		double t3;
		switch (m_interp)
		{
		default:
			t = x - (double)num;
			t2 = y - (double)num2;
			t3 = z - (double)num3;
			break;
		case Interp.Hermite:
			t = InterpHermiteFunc(x - (double)num);
			t2 = InterpHermiteFunc(y - (double)num2);
			t3 = InterpHermiteFunc(z - (double)num3);
			break;
		case Interp.Quintic:
			t = InterpQuinticFunc(x - (double)num);
			t2 = InterpQuinticFunc(y - (double)num2);
			t3 = InterpQuinticFunc(z - (double)num3);
			break;
		}
		double num4 = x - (double)num;
		double num5 = y - (double)num2;
		double num6 = z - (double)num3;
		double xd = num4 - 1.0;
		double yd = num5 - 1.0;
		double zd = num6 - 1.0;
		double a = Lerp(GradCoord3D(seed, num, num2, num3, num4, num5, num6), GradCoord3D(seed, x2, num2, num3, xd, num5, num6), t);
		double b = Lerp(GradCoord3D(seed, num, y2, num3, num4, yd, num6), GradCoord3D(seed, x2, y2, num3, xd, yd, num6), t);
		double a2 = Lerp(GradCoord3D(seed, num, num2, z2, num4, num5, zd), GradCoord3D(seed, x2, num2, z2, xd, num5, zd), t);
		double b2 = Lerp(GradCoord3D(seed, num, y2, z2, num4, yd, zd), GradCoord3D(seed, x2, y2, z2, xd, yd, zd), t);
		double a3 = Lerp(a, b, t2);
		double b3 = Lerp(a2, b2, t2);
		return Lerp(a3, b3, t3);
	}

	public double GetPerlinFractal(double x, double y)
	{
		x *= m_frequency;
		y *= m_frequency;
		return m_fractalType switch
		{
			FractalType.FBM => SinglePerlinFractalFBM(x, y), 
			FractalType.Billow => SinglePerlinFractalBillow(x, y), 
			FractalType.RigidMulti => SinglePerlinFractalRigidMulti(x, y), 
			_ => 0.0, 
		};
	}

	private double SinglePerlinFractalFBM(double x, double y)
	{
		int num = m_seed;
		double num2 = SinglePerlin(num, x, y);
		double num3 = 1.0;
		for (int i = 1; i < m_octaves; i++)
		{
			x *= m_lacunarity;
			y *= m_lacunarity;
			num3 *= m_gain;
			num2 += SinglePerlin(++num, x, y) * num3;
		}
		return num2 * m_fractalBounding;
	}

	private double SinglePerlinFractalBillow(double x, double y)
	{
		int num = m_seed;
		double num2 = Math.Abs(SinglePerlin(num, x, y)) * 2.0 - 1.0;
		double num3 = 1.0;
		for (int i = 1; i < m_octaves; i++)
		{
			x *= m_lacunarity;
			y *= m_lacunarity;
			num3 *= m_gain;
			num2 += (Math.Abs(SinglePerlin(++num, x, y)) * 2.0 - 1.0) * num3;
		}
		return num2 * m_fractalBounding;
	}

	private double SinglePerlinFractalRigidMulti(double x, double y)
	{
		int num = m_seed;
		double num2 = 1.0 - Math.Abs(SinglePerlin(num, x, y));
		double num3 = 1.0;
		for (int i = 1; i < m_octaves; i++)
		{
			x *= m_lacunarity;
			y *= m_lacunarity;
			num3 *= m_gain;
			num2 -= (1.0 - Math.Abs(SinglePerlin(++num, x, y))) * num3;
		}
		return num2;
	}

	public double GetPerlin(double x, double y)
	{
		return SinglePerlin(m_seed, x * m_frequency, y * m_frequency);
	}

	private double SinglePerlin(int seed, double x, double y)
	{
		int num = FastFloor(x);
		int num2 = FastFloor(y);
		int x2 = num + 1;
		int y2 = num2 + 1;
		double t;
		double t2;
		switch (m_interp)
		{
		default:
			t = x - (double)num;
			t2 = y - (double)num2;
			break;
		case Interp.Hermite:
			t = InterpHermiteFunc(x - (double)num);
			t2 = InterpHermiteFunc(y - (double)num2);
			break;
		case Interp.Quintic:
			t = InterpQuinticFunc(x - (double)num);
			t2 = InterpQuinticFunc(y - (double)num2);
			break;
		}
		double num3 = x - (double)num;
		double num4 = y - (double)num2;
		double xd = num3 - 1.0;
		double yd = num4 - 1.0;
		double a = Lerp(GradCoord2D(seed, num, num2, num3, num4), GradCoord2D(seed, x2, num2, xd, num4), t);
		double b = Lerp(GradCoord2D(seed, num, y2, num3, yd), GradCoord2D(seed, x2, y2, xd, yd), t);
		return Lerp(a, b, t2);
	}

	public double GetSimplexFractal(double x, double y, double z)
	{
		x *= m_frequency;
		y *= m_frequency;
		z *= m_frequency;
		return m_fractalType switch
		{
			FractalType.FBM => SingleSimplexFractalFBM(x, y, z), 
			FractalType.Billow => SingleSimplexFractalBillow(x, y, z), 
			FractalType.RigidMulti => SingleSimplexFractalRigidMulti(x, y, z), 
			_ => 0.0, 
		};
	}

	private double SingleSimplexFractalFBM(double x, double y, double z)
	{
		int num = m_seed;
		double num2 = SingleSimplex(num, x, y, z);
		double num3 = 1.0;
		for (int i = 1; i < m_octaves; i++)
		{
			x *= m_lacunarity;
			y *= m_lacunarity;
			z *= m_lacunarity;
			num3 *= m_gain;
			num2 += SingleSimplex(++num, x, y, z) * num3;
		}
		return num2 * m_fractalBounding;
	}

	private double SingleSimplexFractalBillow(double x, double y, double z)
	{
		int num = m_seed;
		double num2 = Math.Abs(SingleSimplex(num, x, y, z)) * 2.0 - 1.0;
		double num3 = 1.0;
		for (int i = 1; i < m_octaves; i++)
		{
			x *= m_lacunarity;
			y *= m_lacunarity;
			z *= m_lacunarity;
			num3 *= m_gain;
			num2 += (Math.Abs(SingleSimplex(++num, x, y, z)) * 2.0 - 1.0) * num3;
		}
		return num2 * m_fractalBounding;
	}

	private double SingleSimplexFractalRigidMulti(double x, double y, double z)
	{
		int num = m_seed;
		double num2 = 1.0 - Math.Abs(SingleSimplex(num, x, y, z));
		double num3 = 1.0;
		for (int i = 1; i < m_octaves; i++)
		{
			x *= m_lacunarity;
			y *= m_lacunarity;
			z *= m_lacunarity;
			num3 *= m_gain;
			num2 -= (1.0 - Math.Abs(SingleSimplex(++num, x, y, z))) * num3;
		}
		return num2;
	}

	public double GetSimplex(double x, double y, double z)
	{
		return SingleSimplex(m_seed, x * m_frequency, y * m_frequency, z * m_frequency);
	}

	private double SingleSimplex(int seed, double x, double y, double z)
	{
		double num = (x + y + z) * (1.0 / 3.0);
		int num2 = FastFloor(x + num);
		int num3 = FastFloor(y + num);
		int num4 = FastFloor(z + num);
		num = (double)(num2 + num3 + num4) * (1.0 / 6.0);
		double num5 = x - ((double)num2 - num);
		double num6 = y - ((double)num3 - num);
		double num7 = z - ((double)num4 - num);
		int num8;
		int num9;
		int num10;
		int num11;
		int num12;
		int num13;
		if (num5 >= num6)
		{
			if (num6 >= num7)
			{
				num8 = 1;
				num9 = 0;
				num10 = 0;
				num11 = 1;
				num12 = 1;
				num13 = 0;
			}
			else if (num5 >= num7)
			{
				num8 = 1;
				num9 = 0;
				num10 = 0;
				num11 = 1;
				num12 = 0;
				num13 = 1;
			}
			else
			{
				num8 = 0;
				num9 = 0;
				num10 = 1;
				num11 = 1;
				num12 = 0;
				num13 = 1;
			}
		}
		else if (num6 < num7)
		{
			num8 = 0;
			num9 = 0;
			num10 = 1;
			num11 = 0;
			num12 = 1;
			num13 = 1;
		}
		else if (num5 < num7)
		{
			num8 = 0;
			num9 = 1;
			num10 = 0;
			num11 = 0;
			num12 = 1;
			num13 = 1;
		}
		else
		{
			num8 = 0;
			num9 = 1;
			num10 = 0;
			num11 = 1;
			num12 = 1;
			num13 = 0;
		}
		double num14 = num5 - (double)num8 + 1.0 / 6.0;
		double num15 = num6 - (double)num9 + 1.0 / 6.0;
		double num16 = num7 - (double)num10 + 1.0 / 6.0;
		double num17 = num5 - (double)num11 + 1.0 / 3.0;
		double num18 = num6 - (double)num12 + 1.0 / 3.0;
		double num19 = num7 - (double)num13 + 1.0 / 3.0;
		double num20 = num5 + -0.5;
		double num21 = num6 + -0.5;
		double num22 = num7 + -0.5;
		num = 0.6 - num5 * num5 - num6 * num6 - num7 * num7;
		double num23;
		if (num < 0.0)
		{
			num23 = 0.0;
		}
		else
		{
			num *= num;
			num23 = num * num * GradCoord3D(seed, num2, num3, num4, num5, num6, num7);
		}
		num = 0.6 - num14 * num14 - num15 * num15 - num16 * num16;
		double num24;
		if (num < 0.0)
		{
			num24 = 0.0;
		}
		else
		{
			num *= num;
			num24 = num * num * GradCoord3D(seed, num2 + num8, num3 + num9, num4 + num10, num14, num15, num16);
		}
		num = 0.6 - num17 * num17 - num18 * num18 - num19 * num19;
		double num25;
		if (num < 0.0)
		{
			num25 = 0.0;
		}
		else
		{
			num *= num;
			num25 = num * num * GradCoord3D(seed, num2 + num11, num3 + num12, num4 + num13, num17, num18, num19);
		}
		num = 0.6 - num20 * num20 - num21 * num21 - num22 * num22;
		double num26;
		if (num < 0.0)
		{
			num26 = 0.0;
		}
		else
		{
			num *= num;
			num26 = num * num * GradCoord3D(seed, num2 + 1, num3 + 1, num4 + 1, num20, num21, num22);
		}
		return 32.0 * (num23 + num24 + num25 + num26);
	}

	public double GetSimplexFractal(double x, double y)
	{
		x *= m_frequency;
		y *= m_frequency;
		return m_fractalType switch
		{
			FractalType.FBM => SingleSimplexFractalFBM(x, y), 
			FractalType.Billow => SingleSimplexFractalBillow(x, y), 
			FractalType.RigidMulti => SingleSimplexFractalRigidMulti(x, y), 
			_ => 0.0, 
		};
	}

	private double SingleSimplexFractalFBM(double x, double y)
	{
		int num = m_seed;
		double num2 = SingleSimplex(num, x, y);
		double num3 = 1.0;
		for (int i = 1; i < m_octaves; i++)
		{
			x *= m_lacunarity;
			y *= m_lacunarity;
			num3 *= m_gain;
			num2 += SingleSimplex(++num, x, y) * num3;
		}
		return num2 * m_fractalBounding;
	}

	private double SingleSimplexFractalBillow(double x, double y)
	{
		int num = m_seed;
		double num2 = Math.Abs(SingleSimplex(num, x, y)) * 2.0 - 1.0;
		double num3 = 1.0;
		for (int i = 1; i < m_octaves; i++)
		{
			x *= m_lacunarity;
			y *= m_lacunarity;
			num3 *= m_gain;
			num2 += (Math.Abs(SingleSimplex(++num, x, y)) * 2.0 - 1.0) * num3;
		}
		return num2 * m_fractalBounding;
	}

	private double SingleSimplexFractalRigidMulti(double x, double y)
	{
		int num = m_seed;
		double num2 = 1.0 - Math.Abs(SingleSimplex(num, x, y));
		double num3 = 1.0;
		for (int i = 1; i < m_octaves; i++)
		{
			x *= m_lacunarity;
			y *= m_lacunarity;
			num3 *= m_gain;
			num2 -= (1.0 - Math.Abs(SingleSimplex(++num, x, y))) * num3;
		}
		return num2;
	}

	public double GetSimplex(double x, double y)
	{
		return SingleSimplex(m_seed, x * m_frequency, y * m_frequency);
	}

	private double SingleSimplex(int seed, double x, double y)
	{
		double num = (x + y) * 0.5;
		int num2 = FastFloor(x + num);
		int num3 = FastFloor(y + num);
		num = (double)(num2 + num3) * 0.25;
		double num4 = (double)num2 - num;
		double num5 = (double)num3 - num;
		double num6 = x - num4;
		double num7 = y - num5;
		int num8;
		int num9;
		if (num6 > num7)
		{
			num8 = 1;
			num9 = 0;
		}
		else
		{
			num8 = 0;
			num9 = 1;
		}
		double num10 = num6 - (double)num8 + 0.25;
		double num11 = num7 - (double)num9 + 0.25;
		double num12 = num6 - 1.0 + 0.5;
		double num13 = num7 - 1.0 + 0.5;
		num = 0.5 - num6 * num6 - num7 * num7;
		double num14;
		if (num < 0.0)
		{
			num14 = 0.0;
		}
		else
		{
			num *= num;
			num14 = num * num * GradCoord2D(seed, num2, num3, num6, num7);
		}
		num = 0.5 - num10 * num10 - num11 * num11;
		double num15;
		if (num < 0.0)
		{
			num15 = 0.0;
		}
		else
		{
			num *= num;
			num15 = num * num * GradCoord2D(seed, num2 + num8, num3 + num9, num10, num11);
		}
		num = 0.5 - num12 * num12 - num13 * num13;
		double num16;
		if (num < 0.0)
		{
			num16 = 0.0;
		}
		else
		{
			num *= num;
			num16 = num * num * GradCoord2D(seed, num2 + 1, num3 + 1, num12, num13);
		}
		return 50.0 * (num14 + num15 + num16);
	}

	public double GetSimplex(double x, double y, double z, double w)
	{
		return SingleSimplex(m_seed, x * m_frequency, y * m_frequency, z * m_frequency, w * m_frequency);
	}

	private double SingleSimplex(int seed, double x, double y, double z, double w)
	{
		double num = (x + y + z + w) * 0.30901699250000003;
		int num2 = FastFloor(x + num);
		int num3 = FastFloor(y + num);
		int num4 = FastFloor(z + num);
		int num5 = FastFloor(w + num);
		num = (double)(num2 + num3 + num4 + num5) * 0.1381966015;
		double num6 = (double)num2 - num;
		double num7 = (double)num3 - num;
		double num8 = (double)num4 - num;
		double num9 = (double)num5 - num;
		double num10 = x - num6;
		double num11 = y - num7;
		double num12 = z - num8;
		double num13 = w - num9;
		int num14 = ((num10 > num11) ? 32 : 0);
		num14 += ((num10 > num12) ? 16 : 0);
		num14 += ((num11 > num12) ? 8 : 0);
		num14 += ((num10 > num13) ? 4 : 0);
		num14 += ((num11 > num13) ? 2 : 0);
		num14 += ((num12 > num13) ? 1 : 0);
		num14 <<= 2;
		int num15 = ((SIMPLEX_4D[num14] >= 3) ? 1 : 0);
		int num16 = ((SIMPLEX_4D[num14] >= 2) ? 1 : 0);
		int num17 = ((SIMPLEX_4D[num14++] >= 1) ? 1 : 0);
		int num18 = ((SIMPLEX_4D[num14] >= 3) ? 1 : 0);
		int num19 = ((SIMPLEX_4D[num14] >= 2) ? 1 : 0);
		int num20 = ((SIMPLEX_4D[num14++] >= 1) ? 1 : 0);
		int num21 = ((SIMPLEX_4D[num14] >= 3) ? 1 : 0);
		int num22 = ((SIMPLEX_4D[num14] >= 2) ? 1 : 0);
		int num23 = ((SIMPLEX_4D[num14++] >= 1) ? 1 : 0);
		int num24 = ((SIMPLEX_4D[num14] >= 3) ? 1 : 0);
		int num25 = ((SIMPLEX_4D[num14] >= 2) ? 1 : 0);
		int num26 = ((SIMPLEX_4D[num14] >= 1) ? 1 : 0);
		double num27 = num10 - (double)num15 + 0.1381966015;
		double num28 = num11 - (double)num18 + 0.1381966015;
		double num29 = num12 - (double)num21 + 0.1381966015;
		double num30 = num13 - (double)num24 + 0.1381966015;
		double num31 = num10 - (double)num16 + 0.276393203;
		double num32 = num11 - (double)num19 + 0.276393203;
		double num33 = num12 - (double)num22 + 0.276393203;
		double num34 = num13 - (double)num25 + 0.276393203;
		double num35 = num10 - (double)num17 + 0.41458980449999994;
		double num36 = num11 - (double)num20 + 0.41458980449999994;
		double num37 = num12 - (double)num23 + 0.41458980449999994;
		double num38 = num13 - (double)num26 + 0.41458980449999994;
		double num39 = num10 - 1.0 + 0.552786406;
		double num40 = num11 - 1.0 + 0.552786406;
		double num41 = num12 - 1.0 + 0.552786406;
		double num42 = num13 - 1.0 + 0.552786406;
		num = 0.6 - num10 * num10 - num11 * num11 - num12 * num12 - num13 * num13;
		double num43;
		if (num < 0.0)
		{
			num43 = 0.0;
		}
		else
		{
			num *= num;
			num43 = num * num * GradCoord4D(seed, num2, num3, num4, num5, num10, num11, num12, num13);
		}
		num = 0.6 - num27 * num27 - num28 * num28 - num29 * num29 - num30 * num30;
		double num44;
		if (num < 0.0)
		{
			num44 = 0.0;
		}
		else
		{
			num *= num;
			num44 = num * num * GradCoord4D(seed, num2 + num15, num3 + num18, num4 + num21, num5 + num24, num27, num28, num29, num30);
		}
		num = 0.6 - num31 * num31 - num32 * num32 - num33 * num33 - num34 * num34;
		double num45;
		if (num < 0.0)
		{
			num45 = 0.0;
		}
		else
		{
			num *= num;
			num45 = num * num * GradCoord4D(seed, num2 + num16, num3 + num19, num4 + num22, num5 + num25, num31, num32, num33, num34);
		}
		num = 0.6 - num35 * num35 - num36 * num36 - num37 * num37 - num38 * num38;
		double num46;
		if (num < 0.0)
		{
			num46 = 0.0;
		}
		else
		{
			num *= num;
			num46 = num * num * GradCoord4D(seed, num2 + num17, num3 + num20, num4 + num23, num5 + num26, num35, num36, num37, num38);
		}
		num = 0.6 - num39 * num39 - num40 * num40 - num41 * num41 - num42 * num42;
		double num47;
		if (num < 0.0)
		{
			num47 = 0.0;
		}
		else
		{
			num *= num;
			num47 = num * num * GradCoord4D(seed, num2 + 1, num3 + 1, num4 + 1, num5 + 1, num39, num40, num41, num42);
		}
		return 27.0 * (num43 + num44 + num45 + num46 + num47);
	}

	public double GetCubicFractal(double x, double y, double z)
	{
		x *= m_frequency;
		y *= m_frequency;
		z *= m_frequency;
		return m_fractalType switch
		{
			FractalType.FBM => SingleCubicFractalFBM(x, y, z), 
			FractalType.Billow => SingleCubicFractalBillow(x, y, z), 
			FractalType.RigidMulti => SingleCubicFractalRigidMulti(x, y, z), 
			_ => 0.0, 
		};
	}

	private double SingleCubicFractalFBM(double x, double y, double z)
	{
		int num = m_seed;
		double num2 = SingleCubic(num, x, y, z);
		double num3 = 1.0;
		int num4 = 0;
		while (++num4 < m_octaves)
		{
			x *= m_lacunarity;
			y *= m_lacunarity;
			z *= m_lacunarity;
			num3 *= m_gain;
			num2 += SingleCubic(++num, x, y, z) * num3;
		}
		return num2 * m_fractalBounding;
	}

	private double SingleCubicFractalBillow(double x, double y, double z)
	{
		int num = m_seed;
		double num2 = Math.Abs(SingleCubic(num, x, y, z)) * 2.0 - 1.0;
		double num3 = 1.0;
		int num4 = 0;
		while (++num4 < m_octaves)
		{
			x *= m_lacunarity;
			y *= m_lacunarity;
			z *= m_lacunarity;
			num3 *= m_gain;
			num2 += (Math.Abs(SingleCubic(++num, x, y, z)) * 2.0 - 1.0) * num3;
		}
		return num2 * m_fractalBounding;
	}

	private double SingleCubicFractalRigidMulti(double x, double y, double z)
	{
		int num = m_seed;
		double num2 = 1.0 - Math.Abs(SingleCubic(num, x, y, z));
		double num3 = 1.0;
		int num4 = 0;
		while (++num4 < m_octaves)
		{
			x *= m_lacunarity;
			y *= m_lacunarity;
			z *= m_lacunarity;
			num3 *= m_gain;
			num2 -= (1.0 - Math.Abs(SingleCubic(++num, x, y, z))) * num3;
		}
		return num2;
	}

	public double GetCubic(double x, double y, double z)
	{
		return SingleCubic(m_seed, x * m_frequency, y * m_frequency, z * m_frequency);
	}

	private double SingleCubic(int seed, double x, double y, double z)
	{
		int num = FastFloor(x);
		int num2 = FastFloor(y);
		int num3 = FastFloor(z);
		int x2 = num - 1;
		int y2 = num2 - 1;
		int z2 = num3 - 1;
		int x3 = num + 1;
		int y3 = num2 + 1;
		int z3 = num3 + 1;
		int x4 = num + 2;
		int y4 = num2 + 2;
		int z4 = num3 + 2;
		double t = x - (double)num;
		double t2 = y - (double)num2;
		double t3 = z - (double)num3;
		return CubicLerp(CubicLerp(CubicLerp(ValCoord3D(seed, x2, y2, z2), ValCoord3D(seed, num, y2, z2), ValCoord3D(seed, x3, y2, z2), ValCoord3D(seed, x4, y2, z2), t), CubicLerp(ValCoord3D(seed, x2, num2, z2), ValCoord3D(seed, num, num2, z2), ValCoord3D(seed, x3, num2, z2), ValCoord3D(seed, x4, num2, z2), t), CubicLerp(ValCoord3D(seed, x2, y3, z2), ValCoord3D(seed, num, y3, z2), ValCoord3D(seed, x3, y3, z2), ValCoord3D(seed, x4, y3, z2), t), CubicLerp(ValCoord3D(seed, x2, y4, z2), ValCoord3D(seed, num, y4, z2), ValCoord3D(seed, x3, y4, z2), ValCoord3D(seed, x4, y4, z2), t), t2), CubicLerp(CubicLerp(ValCoord3D(seed, x2, y2, num3), ValCoord3D(seed, num, y2, num3), ValCoord3D(seed, x3, y2, num3), ValCoord3D(seed, x4, y2, num3), t), CubicLerp(ValCoord3D(seed, x2, num2, num3), ValCoord3D(seed, num, num2, num3), ValCoord3D(seed, x3, num2, num3), ValCoord3D(seed, x4, num2, num3), t), CubicLerp(ValCoord3D(seed, x2, y3, num3), ValCoord3D(seed, num, y3, num3), ValCoord3D(seed, x3, y3, num3), ValCoord3D(seed, x4, y3, num3), t), CubicLerp(ValCoord3D(seed, x2, y4, num3), ValCoord3D(seed, num, y4, num3), ValCoord3D(seed, x3, y4, num3), ValCoord3D(seed, x4, y4, num3), t), t2), CubicLerp(CubicLerp(ValCoord3D(seed, x2, y2, z3), ValCoord3D(seed, num, y2, z3), ValCoord3D(seed, x3, y2, z3), ValCoord3D(seed, x4, y2, z3), t), CubicLerp(ValCoord3D(seed, x2, num2, z3), ValCoord3D(seed, num, num2, z3), ValCoord3D(seed, x3, num2, z3), ValCoord3D(seed, x4, num2, z3), t), CubicLerp(ValCoord3D(seed, x2, y3, z3), ValCoord3D(seed, num, y3, z3), ValCoord3D(seed, x3, y3, z3), ValCoord3D(seed, x4, y3, z3), t), CubicLerp(ValCoord3D(seed, x2, y4, z3), ValCoord3D(seed, num, y4, z3), ValCoord3D(seed, x3, y4, z3), ValCoord3D(seed, x4, y4, z3), t), t2), CubicLerp(CubicLerp(ValCoord3D(seed, x2, y2, z4), ValCoord3D(seed, num, y2, z4), ValCoord3D(seed, x3, y2, z4), ValCoord3D(seed, x4, y2, z4), t), CubicLerp(ValCoord3D(seed, x2, num2, z4), ValCoord3D(seed, num, num2, z4), ValCoord3D(seed, x3, num2, z4), ValCoord3D(seed, x4, num2, z4), t), CubicLerp(ValCoord3D(seed, x2, y3, z4), ValCoord3D(seed, num, y3, z4), ValCoord3D(seed, x3, y3, z4), ValCoord3D(seed, x4, y3, z4), t), CubicLerp(ValCoord3D(seed, x2, y4, z4), ValCoord3D(seed, num, y4, z4), ValCoord3D(seed, x3, y4, z4), ValCoord3D(seed, x4, y4, z4), t), t2), t3) * (8.0 / 27.0);
	}

	public double GetCubicFractal(double x, double y)
	{
		x *= m_frequency;
		y *= m_frequency;
		return m_fractalType switch
		{
			FractalType.FBM => SingleCubicFractalFBM(x, y), 
			FractalType.Billow => SingleCubicFractalBillow(x, y), 
			FractalType.RigidMulti => SingleCubicFractalRigidMulti(x, y), 
			_ => 0.0, 
		};
	}

	private double SingleCubicFractalFBM(double x, double y)
	{
		int num = m_seed;
		double num2 = SingleCubic(num, x, y);
		double num3 = 1.0;
		int num4 = 0;
		while (++num4 < m_octaves)
		{
			x *= m_lacunarity;
			y *= m_lacunarity;
			num3 *= m_gain;
			num2 += SingleCubic(++num, x, y) * num3;
		}
		return num2 * m_fractalBounding;
	}

	private double SingleCubicFractalBillow(double x, double y)
	{
		int num = m_seed;
		double num2 = Math.Abs(SingleCubic(num, x, y)) * 2.0 - 1.0;
		double num3 = 1.0;
		int num4 = 0;
		while (++num4 < m_octaves)
		{
			x *= m_lacunarity;
			y *= m_lacunarity;
			num3 *= m_gain;
			num2 += (Math.Abs(SingleCubic(++num, x, y)) * 2.0 - 1.0) * num3;
		}
		return num2 * m_fractalBounding;
	}

	private double SingleCubicFractalRigidMulti(double x, double y)
	{
		int num = m_seed;
		double num2 = 1.0 - Math.Abs(SingleCubic(num, x, y));
		double num3 = 1.0;
		int num4 = 0;
		while (++num4 < m_octaves)
		{
			x *= m_lacunarity;
			y *= m_lacunarity;
			num3 *= m_gain;
			num2 -= (1.0 - Math.Abs(SingleCubic(++num, x, y))) * num3;
		}
		return num2;
	}

	public double GetCubic(double x, double y)
	{
		x *= m_frequency;
		y *= m_frequency;
		return SingleCubic(0, x, y);
	}

	private double SingleCubic(int seed, double x, double y)
	{
		int num = FastFloor(x);
		int num2 = FastFloor(y);
		int x2 = num - 1;
		int y2 = num2 - 1;
		int x3 = num + 1;
		int y3 = num2 + 1;
		int x4 = num + 2;
		int y4 = num2 + 2;
		double t = x - (double)num;
		double t2 = y - (double)num2;
		return CubicLerp(CubicLerp(ValCoord2D(seed, x2, y2), ValCoord2D(seed, num, y2), ValCoord2D(seed, x3, y2), ValCoord2D(seed, x4, y2), t), CubicLerp(ValCoord2D(seed, x2, num2), ValCoord2D(seed, num, num2), ValCoord2D(seed, x3, num2), ValCoord2D(seed, x4, num2), t), CubicLerp(ValCoord2D(seed, x2, y3), ValCoord2D(seed, num, y3), ValCoord2D(seed, x3, y3), ValCoord2D(seed, x4, y3), t), CubicLerp(ValCoord2D(seed, x2, y4), ValCoord2D(seed, num, y4), ValCoord2D(seed, x3, y4), ValCoord2D(seed, x4, y4), t), t2) * (4.0 / 9.0);
	}

	public double GetCellular(double x, double y, double z)
	{
		x *= m_frequency;
		y *= m_frequency;
		z *= m_frequency;
		CellularReturnType cellularReturnType = m_cellularReturnType;
		if ((uint)cellularReturnType <= 2u)
		{
			return SingleCellular(x, y, z);
		}
		return SingleCellular2Edge(x, y, z);
	}

	private double SingleCellular(double x, double y, double z)
	{
		int num = FastRound(x);
		int num2 = FastRound(y);
		int num3 = FastRound(z);
		double num4 = 999999.0;
		int num5 = 0;
		int num6 = 0;
		int num7 = 0;
		switch (m_cellularDistanceFunction)
		{
		case CellularDistanceFunction.Euclidean:
		{
			for (int l = num - 1; l <= num + 1; l++)
			{
				for (int m = num2 - 1; m <= num2 + 1; m++)
				{
					for (int n = num3 - 1; n <= num3 + 1; n++)
					{
						Float3 float2 = CELL_3D[Hash3D(m_seed, l, m, n) & 0xFF];
						double num12 = (double)l - x + float2.x * (double)m_cellularJitter;
						double num13 = (double)m - y + float2.y * (double)m_cellularJitter;
						double num14 = (double)n - z + float2.z * (double)m_cellularJitter;
						double num15 = num12 * num12 + num13 * num13 + num14 * num14;
						if (num15 < num4)
						{
							num4 = num15;
							num5 = l;
							num6 = m;
							num7 = n;
						}
					}
				}
			}
			break;
		}
		case CellularDistanceFunction.Manhattan:
		{
			for (int num16 = num - 1; num16 <= num + 1; num16++)
			{
				for (int num17 = num2 - 1; num17 <= num2 + 1; num17++)
				{
					for (int num18 = num3 - 1; num18 <= num3 + 1; num18++)
					{
						Float3 float3 = CELL_3D[Hash3D(m_seed, num16, num17, num18) & 0xFF];
						double value = (double)num16 - x + float3.x * (double)m_cellularJitter;
						double value2 = (double)num17 - y + float3.y * (double)m_cellularJitter;
						double value3 = (double)num18 - z + float3.z * (double)m_cellularJitter;
						double num19 = Math.Abs(value) + Math.Abs(value2) + Math.Abs(value3);
						if (num19 < num4)
						{
							num4 = num19;
							num5 = num16;
							num6 = num17;
							num7 = num18;
						}
					}
				}
			}
			break;
		}
		case CellularDistanceFunction.Natural:
		{
			for (int i = num - 1; i <= num + 1; i++)
			{
				for (int j = num2 - 1; j <= num2 + 1; j++)
				{
					for (int k = num3 - 1; k <= num3 + 1; k++)
					{
						Float3 @float = CELL_3D[Hash3D(m_seed, i, j, k) & 0xFF];
						double num8 = (double)i - x + @float.x * (double)m_cellularJitter;
						double num9 = (double)j - y + @float.y * (double)m_cellularJitter;
						double num10 = (double)k - z + @float.z * (double)m_cellularJitter;
						double num11 = Math.Abs(num8) + Math.Abs(num9) + Math.Abs(num10) + (num8 * num8 + num9 * num9 + num10 * num10);
						if (num11 < num4)
						{
							num4 = num11;
							num5 = i;
							num6 = j;
							num7 = k;
						}
					}
				}
			}
			break;
		}
		}
		switch (m_cellularReturnType)
		{
		case CellularReturnType.CellValue:
			return ValCoord3D(m_seed, num5, num6, num7);
		case CellularReturnType.NoiseLookup:
		{
			Float3 float4 = CELL_3D[Hash3D(m_seed, num5, num6, num7) & 0xFF];
			return m_cellularNoiseLookup.GetNoise((double)num5 + float4.x * (double)m_cellularJitter, (double)num6 + float4.y * (double)m_cellularJitter, (double)num7 + float4.z * (double)m_cellularJitter);
		}
		case CellularReturnType.Distance:
			return num4;
		default:
			return 0.0;
		}
	}

	private double SingleCellular2Edge(double x, double y, double z)
	{
		int num = FastRound(x);
		int num2 = FastRound(y);
		int num3 = FastRound(z);
		double[] array = new double[4] { 999999.0, 999999.0, 999999.0, 999999.0 };
		switch (m_cellularDistanceFunction)
		{
		case CellularDistanceFunction.Euclidean:
		{
			for (int l = num - 1; l <= num + 1; l++)
			{
				for (int m = num2 - 1; m <= num2 + 1; m++)
				{
					for (int n = num3 - 1; n <= num3 + 1; n++)
					{
						Float3 float2 = CELL_3D[Hash3D(m_seed, l, m, n) & 0xFF];
						double num8 = (double)l - x + float2.x * (double)m_cellularJitter;
						double num9 = (double)m - y + float2.y * (double)m_cellularJitter;
						double num10 = (double)n - z + float2.z * (double)m_cellularJitter;
						double val2 = num8 * num8 + num9 * num9 + num10 * num10;
						for (int num11 = m_cellularDistanceIndex1; num11 > 0; num11--)
						{
							array[num11] = Math.Max(Math.Min(array[num11], val2), array[num11 - 1]);
						}
						array[0] = Math.Min(array[0], val2);
					}
				}
			}
			break;
		}
		case CellularDistanceFunction.Manhattan:
		{
			for (int num12 = num - 1; num12 <= num + 1; num12++)
			{
				for (int num13 = num2 - 1; num13 <= num2 + 1; num13++)
				{
					for (int num14 = num3 - 1; num14 <= num3 + 1; num14++)
					{
						Float3 float3 = CELL_3D[Hash3D(m_seed, num12, num13, num14) & 0xFF];
						double value = (double)num12 - x + float3.x * (double)m_cellularJitter;
						double value2 = (double)num13 - y + float3.y * (double)m_cellularJitter;
						double value3 = (double)num14 - z + float3.z * (double)m_cellularJitter;
						double val3 = Math.Abs(value) + Math.Abs(value2) + Math.Abs(value3);
						for (int num15 = m_cellularDistanceIndex1; num15 > 0; num15--)
						{
							array[num15] = Math.Max(Math.Min(array[num15], val3), array[num15 - 1]);
						}
						array[0] = Math.Min(array[0], val3);
					}
				}
			}
			break;
		}
		case CellularDistanceFunction.Natural:
		{
			for (int i = num - 1; i <= num + 1; i++)
			{
				for (int j = num2 - 1; j <= num2 + 1; j++)
				{
					for (int k = num3 - 1; k <= num3 + 1; k++)
					{
						Float3 @float = CELL_3D[Hash3D(m_seed, i, j, k) & 0xFF];
						double num4 = (double)i - x + @float.x * (double)m_cellularJitter;
						double num5 = (double)j - y + @float.y * (double)m_cellularJitter;
						double num6 = (double)k - z + @float.z * (double)m_cellularJitter;
						double val = Math.Abs(num4) + Math.Abs(num5) + Math.Abs(num6) + (num4 * num4 + num5 * num5 + num6 * num6);
						for (int num7 = m_cellularDistanceIndex1; num7 > 0; num7--)
						{
							array[num7] = Math.Max(Math.Min(array[num7], val), array[num7 - 1]);
						}
						array[0] = Math.Min(array[0], val);
					}
				}
			}
			break;
		}
		}
		return m_cellularReturnType switch
		{
			CellularReturnType.Distance2 => array[m_cellularDistanceIndex1], 
			CellularReturnType.Distance2Add => array[m_cellularDistanceIndex1] + array[m_cellularDistanceIndex0], 
			CellularReturnType.Distance2Sub => array[m_cellularDistanceIndex1] - array[m_cellularDistanceIndex0], 
			CellularReturnType.Distance2Mul => array[m_cellularDistanceIndex1] * array[m_cellularDistanceIndex0], 
			CellularReturnType.Distance2Div => array[m_cellularDistanceIndex0] / array[m_cellularDistanceIndex1], 
			_ => 0.0, 
		};
	}

	public double GetCellular(double x, double y)
	{
		x *= m_frequency;
		y *= m_frequency;
		CellularReturnType cellularReturnType = m_cellularReturnType;
		if ((uint)cellularReturnType <= 2u)
		{
			return SingleCellular(x, y);
		}
		return SingleCellular2Edge(x, y);
	}

	private double SingleCellular(double x, double y)
	{
		int num = FastRound(x);
		int num2 = FastRound(y);
		double num3 = 999999.0;
		int num4 = 0;
		int num5 = 0;
		switch (m_cellularDistanceFunction)
		{
		default:
		{
			for (int k = num - 1; k <= num + 1; k++)
			{
				for (int l = num2 - 1; l <= num2 + 1; l++)
				{
					Float2 float2 = CELL_2D[Hash2D(m_seed, k, l) & 0xFF];
					double num9 = (double)k - x + float2.x * (double)m_cellularJitter;
					double num10 = (double)l - y + float2.y * (double)m_cellularJitter;
					double num11 = num9 * num9 + num10 * num10;
					if (num11 < num3)
					{
						num3 = num11;
						num4 = k;
						num5 = l;
					}
				}
			}
			break;
		}
		case CellularDistanceFunction.Manhattan:
		{
			for (int m = num - 1; m <= num + 1; m++)
			{
				for (int n = num2 - 1; n <= num2 + 1; n++)
				{
					Float2 float3 = CELL_2D[Hash2D(m_seed, m, n) & 0xFF];
					double value = (double)m - x + float3.x * (double)m_cellularJitter;
					double value2 = (double)n - y + float3.y * (double)m_cellularJitter;
					double num12 = Math.Abs(value) + Math.Abs(value2);
					if (num12 < num3)
					{
						num3 = num12;
						num4 = m;
						num5 = n;
					}
				}
			}
			break;
		}
		case CellularDistanceFunction.Natural:
		{
			for (int i = num - 1; i <= num + 1; i++)
			{
				for (int j = num2 - 1; j <= num2 + 1; j++)
				{
					Float2 @float = CELL_2D[Hash2D(m_seed, i, j) & 0xFF];
					double num6 = (double)i - x + @float.x * (double)m_cellularJitter;
					double num7 = (double)j - y + @float.y * (double)m_cellularJitter;
					double num8 = Math.Abs(num6) + Math.Abs(num7) + (num6 * num6 + num7 * num7);
					if (num8 < num3)
					{
						num3 = num8;
						num4 = i;
						num5 = j;
					}
				}
			}
			break;
		}
		}
		switch (m_cellularReturnType)
		{
		case CellularReturnType.CellValue:
			return ValCoord2D(m_seed, num4, num5);
		case CellularReturnType.NoiseLookup:
		{
			Float2 float4 = CELL_2D[Hash2D(m_seed, num4, num5) & 0xFF];
			return m_cellularNoiseLookup.GetNoise((double)num4 + float4.x * (double)m_cellularJitter, (double)num5 + float4.y * (double)m_cellularJitter);
		}
		case CellularReturnType.Distance:
			return num3;
		default:
			return 0.0;
		}
	}

	private double SingleCellular2Edge(double x, double y)
	{
		int num = FastRound(x);
		int num2 = FastRound(y);
		double[] array = new double[4] { 999999.0, 999999.0, 999999.0, 999999.0 };
		switch (m_cellularDistanceFunction)
		{
		default:
		{
			for (int k = num - 1; k <= num + 1; k++)
			{
				for (int l = num2 - 1; l <= num2 + 1; l++)
				{
					Float2 float2 = CELL_2D[Hash2D(m_seed, k, l) & 0xFF];
					double num6 = (double)k - x + float2.x * (double)m_cellularJitter;
					double num7 = (double)l - y + float2.y * (double)m_cellularJitter;
					double val2 = num6 * num6 + num7 * num7;
					for (int num8 = m_cellularDistanceIndex1; num8 > 0; num8--)
					{
						array[num8] = Math.Max(Math.Min(array[num8], val2), array[num8 - 1]);
					}
					array[0] = Math.Min(array[0], val2);
				}
			}
			break;
		}
		case CellularDistanceFunction.Manhattan:
		{
			for (int m = num - 1; m <= num + 1; m++)
			{
				for (int n = num2 - 1; n <= num2 + 1; n++)
				{
					Float2 float3 = CELL_2D[Hash2D(m_seed, m, n) & 0xFF];
					double value = (double)m - x + float3.x * (double)m_cellularJitter;
					double value2 = (double)n - y + float3.y * (double)m_cellularJitter;
					double val3 = Math.Abs(value) + Math.Abs(value2);
					for (int num9 = m_cellularDistanceIndex1; num9 > 0; num9--)
					{
						array[num9] = Math.Max(Math.Min(array[num9], val3), array[num9 - 1]);
					}
					array[0] = Math.Min(array[0], val3);
				}
			}
			break;
		}
		case CellularDistanceFunction.Natural:
		{
			for (int i = num - 1; i <= num + 1; i++)
			{
				for (int j = num2 - 1; j <= num2 + 1; j++)
				{
					Float2 @float = CELL_2D[Hash2D(m_seed, i, j) & 0xFF];
					double num3 = (double)i - x + @float.x * (double)m_cellularJitter;
					double num4 = (double)j - y + @float.y * (double)m_cellularJitter;
					double val = Math.Abs(num3) + Math.Abs(num4) + (num3 * num3 + num4 * num4);
					for (int num5 = m_cellularDistanceIndex1; num5 > 0; num5--)
					{
						array[num5] = Math.Max(Math.Min(array[num5], val), array[num5 - 1]);
					}
					array[0] = Math.Min(array[0], val);
				}
			}
			break;
		}
		}
		return m_cellularReturnType switch
		{
			CellularReturnType.Distance2 => array[m_cellularDistanceIndex1], 
			CellularReturnType.Distance2Add => array[m_cellularDistanceIndex1] + array[m_cellularDistanceIndex0], 
			CellularReturnType.Distance2Sub => array[m_cellularDistanceIndex1] - array[m_cellularDistanceIndex0], 
			CellularReturnType.Distance2Mul => array[m_cellularDistanceIndex1] * array[m_cellularDistanceIndex0], 
			CellularReturnType.Distance2Div => array[m_cellularDistanceIndex0] / array[m_cellularDistanceIndex1], 
			_ => 0.0, 
		};
	}

	public void GradientPerturb(ref double x, ref double y, ref double z)
	{
		SingleGradientPerturb(m_seed, m_gradientPerturbAmp, m_frequency, ref x, ref y, ref z);
	}

	public void GradientPerturbFractal(ref double x, ref double y, ref double z)
	{
		int num = m_seed;
		double num2 = m_gradientPerturbAmp * m_fractalBounding;
		double num3 = m_frequency;
		SingleGradientPerturb(num, num2, m_frequency, ref x, ref y, ref z);
		for (int i = 1; i < m_octaves; i++)
		{
			num3 *= m_lacunarity;
			num2 *= m_gain;
			SingleGradientPerturb(++num, num2, num3, ref x, ref y, ref z);
		}
	}

	private void SingleGradientPerturb(int seed, double perturbAmp, double frequency, ref double x, ref double y, ref double z)
	{
		double num = x * frequency;
		double num2 = y * frequency;
		double num3 = z * frequency;
		int num4 = FastFloor(num);
		int num5 = FastFloor(num2);
		int num6 = FastFloor(num3);
		int x2 = num4 + 1;
		int y2 = num5 + 1;
		int z2 = num6 + 1;
		double t;
		double t2;
		double t3;
		switch (m_interp)
		{
		default:
			t = num - (double)num4;
			t2 = num2 - (double)num5;
			t3 = num3 - (double)num6;
			break;
		case Interp.Hermite:
			t = InterpHermiteFunc(num - (double)num4);
			t2 = InterpHermiteFunc(num2 - (double)num5);
			t3 = InterpHermiteFunc(num3 - (double)num6);
			break;
		case Interp.Quintic:
			t = InterpQuinticFunc(num - (double)num4);
			t2 = InterpQuinticFunc(num2 - (double)num5);
			t3 = InterpQuinticFunc(num3 - (double)num6);
			break;
		}
		Float3 @float = CELL_3D[Hash3D(seed, num4, num5, num6) & 0xFF];
		Float3 float2 = CELL_3D[Hash3D(seed, x2, num5, num6) & 0xFF];
		double a = Lerp(@float.x, float2.x, t);
		double a2 = Lerp(@float.y, float2.y, t);
		double a3 = Lerp(@float.z, float2.z, t);
		Float3 float3 = CELL_3D[Hash3D(seed, num4, y2, num6) & 0xFF];
		float2 = CELL_3D[Hash3D(seed, x2, y2, num6) & 0xFF];
		double b = Lerp(float3.x, float2.x, t);
		double b2 = Lerp(float3.y, float2.y, t);
		double b3 = Lerp(float3.z, float2.z, t);
		double a4 = Lerp(a, b, t2);
		double a5 = Lerp(a2, b2, t2);
		double a6 = Lerp(a3, b3, t2);
		Float3 float4 = CELL_3D[Hash3D(seed, num4, num5, z2) & 0xFF];
		float2 = CELL_3D[Hash3D(seed, x2, num5, z2) & 0xFF];
		a = Lerp(float4.x, float2.x, t);
		a2 = Lerp(float4.y, float2.y, t);
		a3 = Lerp(float4.z, float2.z, t);
		Float3 float5 = CELL_3D[Hash3D(seed, num4, y2, z2) & 0xFF];
		float2 = CELL_3D[Hash3D(seed, x2, y2, z2) & 0xFF];
		b = Lerp(float5.x, float2.x, t);
		b2 = Lerp(float5.y, float2.y, t);
		b3 = Lerp(float5.z, float2.z, t);
		x += Lerp(a4, Lerp(a, b, t2), t3) * perturbAmp;
		y += Lerp(a5, Lerp(a2, b2, t2), t3) * perturbAmp;
		z += Lerp(a6, Lerp(a3, b3, t2), t3) * perturbAmp;
	}

	public void GradientPerturb(ref double x, ref double y)
	{
		SingleGradientPerturb(m_seed, m_gradientPerturbAmp, m_frequency, ref x, ref y);
	}

	public void GradientPerturbFractal(ref double x, ref double y)
	{
		int num = m_seed;
		double num2 = m_gradientPerturbAmp * m_fractalBounding;
		double num3 = m_frequency;
		SingleGradientPerturb(num, num2, m_frequency, ref x, ref y);
		for (int i = 1; i < m_octaves; i++)
		{
			num3 *= m_lacunarity;
			num2 *= m_gain;
			SingleGradientPerturb(++num, num2, num3, ref x, ref y);
		}
	}

	private void SingleGradientPerturb(int seed, double perturbAmp, double frequency, ref double x, ref double y)
	{
		double num = x * frequency;
		double num2 = y * frequency;
		int num3 = FastFloor(num);
		int num4 = FastFloor(num2);
		int x2 = num3 + 1;
		int y2 = num4 + 1;
		double t;
		double t2;
		switch (m_interp)
		{
		default:
			t = num - (double)num3;
			t2 = num2 - (double)num4;
			break;
		case Interp.Hermite:
			t = InterpHermiteFunc(num - (double)num3);
			t2 = InterpHermiteFunc(num2 - (double)num4);
			break;
		case Interp.Quintic:
			t = InterpQuinticFunc(num - (double)num3);
			t2 = InterpQuinticFunc(num2 - (double)num4);
			break;
		}
		Float2 @float = CELL_2D[Hash2D(seed, num3, num4) & 0xFF];
		Float2 float2 = CELL_2D[Hash2D(seed, x2, num4) & 0xFF];
		double a = Lerp(@float.x, float2.x, t);
		double a2 = Lerp(@float.y, float2.y, t);
		Float2 float3 = CELL_2D[Hash2D(seed, num3, y2) & 0xFF];
		float2 = CELL_2D[Hash2D(seed, x2, y2) & 0xFF];
		double b = Lerp(float3.x, float2.x, t);
		double b2 = Lerp(float3.y, float2.y, t);
		x += Lerp(a, b, t2) * perturbAmp;
		y += Lerp(a2, b2, t2) * perturbAmp;
	}
}
